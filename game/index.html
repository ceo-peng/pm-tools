<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Block Brawl v6.0 ‚Äî Full Final (Single File)</title>
<style>
/* =======================================================================
   Block Brawl v6.0 ‚Äî Full Final (Single File, No external assets)
   - Vanilla JS + Canvas + CSS
   - 2.5D Roblox-style boxing + kicks + shoryu + roll + AI + FX + Music + Pets
   - Skins editor, Controls remap, Accessibility, Deterministic AI RNG
   - Runs offline, Chromebook-friendly (60 FPS target)
   ======================================================================= */
:root{
  --bg:#0e0f13; --panel:#171923; --panel2:#1f2230; --text:#e8ebff;
  --muted:#a8b0d3; --accent:#6ea8fe; --good:#63e6be; --danger:#ff6b6b; --warn:#ffd166;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
.wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px}
h1{margin:8px 0 0} .sub{color:var(--muted);margin-top:-6px}
.card{background:linear-gradient(180deg,var(--panel),var(--panel2));
  border:1px solid #2a2e42;border-radius:14px;box-shadow:0 4px 18px rgba(0,0,0,.25)}
.hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:8px 12px}
.btn{background:var(--panel2);border:1px solid #2a2e42;border-radius:12px;color:var(--text);
  padding:10px 14px;font-weight:700;cursor:pointer}
.btn:hover{filter:brightness(1.08)} .btn:active{transform:translateY(1px)}
.select,.input{background:var(--panel2);border:1px solid #2a2e42;border-radius:10px;color:var(--text);
  padding:8px 10px;font-weight:600}
canvas{background:#10131f;border:1px solid #2a2e42;border-radius:16px;display:block;max-width:100%;height:auto}
.bars{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:6px}
.bar{height:12px;border-radius:8px;background:#2a2e42;position:relative;overflow:hidden}
.fill{position:absolute;left:0;top:0;bottom:0;border-radius:8px}
.health{background:linear-gradient(90deg,#ff8a8a,#ff6b6b)}
.stamina{background:linear-gradient(90deg,#a1ffe7,#63e6be)}
.super{background:linear-gradient(90deg,#9bb8ff,#6ea8fe)}
.footer{color:#8891bb;font-size:.85rem;margin-top:-6px;text-align:center}
.k{background:#272a3d;border-radius:8px;padding:3px 6px;border:1px solid #35395a}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
.modal{width:min(1024px,96vw);padding:16px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:10px} .grid2{grid-template-columns:1fr 1fr}
.small{font-size:.9rem;color:var(--muted)} .right{margin-left:auto}
.tag{font-size:.78rem;padding:2px 6px;border:1px solid #35395a;border-radius:999px;color:#a8b0d3}
.checkbox{display:inline-flex;gap:8px;align-items:center}
hr.sep{border:none;border-top:1px solid #2a2e42;margin:6px 0}

/* Color-blind palette variants toggled by JS */
.cb-health{background:linear-gradient(90deg,#73b2ff,#4677ff)}
.cb-stamina{background:linear-gradient(90deg,#ffd166,#ffb703)}
.cb-super{background:linear-gradient(90deg,#a1e3a1,#63c763)}
</style>
</head>
<body>
<div class="wrap">
  <h1>üß± Block Brawl v6.0</h1>
  <div class="sub">Final single-file build ‚Äî v4.5 core merged with all later features (announcer, music, kicks/shoryu/roll, advanced hitboxes, pets, skins, accessibility, AI & FX)</div>

  <div class="card hud">
    <button id="btnPlay" class="btn">‚ñ∂ Play</button>
    <button id="btnPause" class="btn">Pause (P)</button>
    <div class="row"><span class="tag">Mode</span>
      <select id="selDiff" class="select"><option>Easy</option><option selected>Normal</option><option>Hard</option></select>
    </div>
    <button id="btnSkins" class="btn">Skins</button>
    <button id="btnPets" class="btn">Pets</button>
    <button id="btnMusic" class="btn">Music</button>
    <button id="btnControls" class="btn">Controls</button>
    <button id="btnAccessibility" class="btn">Accessibility</button>
    <span class="right"><strong id="roundTag">Round 1 / 3</strong>&nbsp;<span id="timer">01:00</span></span>
  </div>

  <div class="card" style="padding:10px;width:min(1120px,96vw)">
    <div class="row" style="justify-content:space-between"><div><strong>Player</strong></div><div><strong>CPU</strong></div></div>
    <div class="bars">
      <div class="grid">
        <div class="bar"><div id="pHealth" class="fill health" style="width:0%"></div></div>
        <div class="bar"><div id="pStamina" class="fill stamina" style="width:0%"></div></div>
        <div class="bar"><div id="pSuper" class="fill super" style="width:0%"></div></div>
      </div>
      <div class="grid">
        <div class="bar"><div id="eHealth" class="fill health" style="width:0%"></div></div>
        <div class="bar"><div id="eStamina" class="fill stamina" style="width:0%"></div></div>
        <div class="bar"><div id="eSuper" class="fill super" style="width:0%"></div></div>
      </div>
    </div>
  </div>

  <canvas id="game" width="960" height="540"></canvas>
  <div class="footer">
    Move A/D ‚Ä¢ Step W/S ‚Ä¢ J/K/L Êã≥ ‚Ä¢ I Ê†ºÊìã ‚Ä¢ O ÈñÉÈÅø ‚Ä¢ <b>H ÂâçË∏¢</b> ‚Ä¢ <b>G Ëø¥ÊóãË∏¢</b> ‚Ä¢ <b>U ÊòáÈæçÊã≥</b> ‚Ä¢ <b>Shift ÁøªÊªæ</b> ‚Ä¢ Super <span class="k">Space</span><br/>
    Debug <span class="k">/</span> ‚Ä¢ Restart <span class="k">R</span> ‚Ä¢ Pause <span class="k">P</span>
  </div>
</div>

<!-- Modal -->
<div id="modalBackdrop" class="modal-backdrop">
  <div class="modal card">
    <h3 id="modalTitle">Info</h3>
    <div id="modalBody" class="grid"></div>
    <div class="row" style="justify-content:flex-end"><button id="modalClose" class="btn">OK</button></div>
  </div>
</div>

<script>
/* =============================================================================
README ‚Äî v6.0 Full Final (Single-file index.html)
- Double-click to run offline. No images, no external libs. Everything is drawn or
  synthesized (WebAudio) in code.
- Controls: A/D (‚Üê/‚Üí) move, W/S (‚Üë/‚Üì) step, J/K/L punches, I block, O dodge,
  H teep, G roundhouse, U shoryu, Shift roll, Space super, P pause, / debug, R restart.
- Panels: Skins (colors/body/hair/face/scale, Gorilla body toggle), Pets (Panda/Fox/Boston/French/Crab),
  Music (3 tracks + Off, volume), Controls (key remap, RNG seed/lock), Accessibility
  (reduce flashing, color-blind bars, SFX mute). Saved to localStorage.
- Systems: Fixed-timestep update (60 FPS), advanced multi-segment hitboxes (upper/forearm),
  foot hitbox for kicks, gait speed modulation, i-frames on dodge/roll/shoryu, AI states,
  combo window, particles (sparks, stars, speedlines, afterimages), announcer voice and stinger,
  Kung Fu Panda-ish dojo background (pure Canvas), ring ropes & crowd simplified.
- Tuning: All knobs inside GAME_CONFIG (damage, frames, speeds, stamina, round length, AI weight).
- Acceptance: Easy beatable ~5 minutes, Hard challenging; no crashes; debug overlay shows hitboxes/FPS/AI.

Where to tweak difficulty quickly:
  - GAME_CONFIG.difficulty.Easy/Normal/Hard  (enemyHp/enemyDmg/enemySpeed/aiAggro/aiDefend/aiRandom)
  - GAME_CONFIG.round.seconds and suddenDeath
  - GAME_CONFIG.moves (frame data/damage)
============================================================================= */

/* =============================== Global Config ============================ */
const GAME_CONFIG = {
  version: '6.0',
  canvas: { width: 960, height: 540, groundY: 420, ring: { left: 80, right: 880 } },
  timing: { fps: 60, stepMs: 1000/60 },
  round: { seconds: 60, suddenDeath: 15, bestOf: 3 },
  random: { seed: 1337, lock: true },   // lock=true for deterministic AI; you can toggle in Controls
  audio: { master: 0.26, musicVol: 0.55, reduceFlashing: false, soundOn: true, musicOn: true, track: 'Arcade Rush' },
  ui: { colorBlind: false, showTutorialOnFirstRun: true },
  player: { width: 54, height: 104, moveSpeed: 4.2, dash: 6.5, dashCd: 420, maxHealth: 100, maxStamina: 100, staminaRegen: 14, staminaDrainMove: 2, blockMitigation: 0.6, dodgeIFrames: 260, pushback: 3.2, superGainOnHit: 8, superGainOnBlock: 4, maxSuper: 100, comboWindowMs: 450, hitstunMs: 220, gaitSpeed: 0.020 },
  enemy:  { width: 54, height: 104, moveSpeed: 3.8, dash: 6.0, dashCd: 480, maxHealth: 100, maxStamina: 100, staminaRegen: 12, staminaDrainMove: 2, blockMitigation: 0.55, dodgeIFrames: 220, pushback: 3.0, superGainOnHit: 8, superGainOnBlock: 4, maxSuper: 100, comboWindowMs: 420, hitstunMs: 200, gaitSpeed: 0.018 },
  moves: {
    jab:        { dmg: 8,  stamina: 10, range: 62, startup: 90,  active: 120, recovery: 180, knock: 0.6 },
    hook:       { dmg: 14, stamina: 16, range: 58, startup: 140, active: 110, recovery: 220, knock: 1.0 },
    upper:      { dmg: 20, stamina: 22, range: 58, startup: 180, active: 120, recovery: 260, knock: 1.3 },
    super:      { dmg: 36, stamina: 0,  range: 76, startup: 220, active: 160, recovery: 340, knock: 1.6 },
    teep:       { dmg: 16, stamina: 18, range: 78, startup: 140, active: 130, recovery: 220, knock: 1.2, type: 'kick' },
    roundhouse: { dmg: 22, stamina: 24, range: 92, startup: 200, active: 150, recovery: 280, knock: 1.5, spin: true, type: 'kick' },
    shoryu:     { dmg: 26, stamina: 24, range: 70, startup: 140, active: 160, recovery: 280, knock: 1.7, rise: 1, iframes: 220 },
    roll:       { dmg: 0,  stamina: 10, range: 0,  startup: 40,  active: 180, recovery: 120, knock: 0, roll: true }
  },
  hitbox: { upperBox: { w: 18, h: 18, scaleDmg: 0.7 }, foreBox: { w: 20, h: 20, scaleDmg: 1.0 }, foot:{ w:28, h:20 } },
  gait: { stepBoost: 0.18, minFactor: 0.75 },
  fx: { afterimage:{ spawnEveryMs:36, life:260, alpha:0.32 }, stars:{ count:6, life:900, radius:18 }, speedlines:{ count:12, life:260 }, sparkPool:128, starPool:64, ghostPool:64 },
  render: { outline:'#0a0b12', outlineW:2.2, shadeMul:0.65, headGloss:0.18 },
  difficulty: {
    Easy:   { enemyHp: 0.90, enemyDmg: 0.85, enemySpeed: 0.95, aiAggro: 0.72, aiDefend: 0.85, aiRandom: 0.25 },
    Normal: { enemyHp: 1.00, enemyDmg: 1.00, enemySpeed: 1.00, aiAggro: 0.92, aiDefend: 1.00, aiRandom: 0.18 },
    Hard:   { enemyHp: 1.15, enemyDmg: 1.10, enemySpeed: 1.05, aiAggro: 1.12, aiDefend: 1.08, aiRandom: 0.12 }
  },
  skins: {
    defaults: {
      player: { name:'Player', skin:'#f6c9a0', hair:'#2b2b2b', glove:'#ffd166', top:'#63e6be', pant:'#2a2e42', wrap:'#9bb8ff', face:'smile', hairStyle:'spiky', scale:{height:1,arm:1,torso:1}, bodyStyle:'Human' },
      cpu:    { name:'CPU',    skin:'#f1d3b3', hair:'#1f3b7a', glove:'#ff6b6b', top:'#6ea8fe', pant:'#1f2a44', wrap:'#ffd166', face:'determined', hairStyle:'short', scale:{height:1.02,arm:1.02,torso:0.98}, bodyStyle:'Human' }
    },
    hair: ['none','short','spiky','bob','long'],
    face: ['smile','determined','stoic'],
    body: ['Human','Gorilla']
  },
  pets: { type:'None', offsetX:-90, followLerp:0.14, hopVY:-4.2, gravity:0.22, bobAmp:3, cheerMs:600, list:['None','Panda','Fox','Boston Terrier','French Bulldog','Crab'] }
};

/* ========================== Deterministic RNG ============================= */
let _seed = GAME_CONFIG.random.seed >>> 0; // xorshift32
function srand(seed){ _seed = seed>>>0; }
function srandom(){
  if(!GAME_CONFIG.random.lock) return Math.random();
  _seed ^= _seed << 13; _seed ^= _seed >>> 17; _seed ^= _seed << 5;
  return ((_seed>>>0) / 4294967296);
}
function rand(a,b){ return srandom()*(b-a)+a; }
function chance(p){ return srandom() < p; }

/* ================================ Helpers ================================= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const nowMs=()=>performance.now();
const fmtTime=s=>{s=Math.max(0,Math.floor(s));return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`};
const lerp=(a,b,t)=>a+(b-a)*t;
function hexToRgb(hex){ const m=hex.replace('#',''); const n=parseInt(m,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function shade(hex,mul){ const {r,g,b}=hexToRgb(hex); return `rgb(${clamp(Math.round(r*mul),0,255)},${clamp(Math.round(g*mul),0,255)},${clamp(Math.round(b*mul),0,255)})`; }

/* ================================ Input =================================== */
const DEFAULT_KEYS={
  left:['a','arrowleft'], right:['d','arrowright'], stepF:['w','arrowup'], stepB:['s','arrowdown'],
  jab:['j'], hook:['k'], upper:['l'], block:['i'], dodge:['o'], super:[' '], pause:['p'], debug:['/'], restart:['r'],
  teep:['h'], roundhouse:['g'], shoryu:['u'], roll:['shift']
};
let KEY_MAP=JSON.parse(localStorage.getItem('bb_keys')||'null')||DEFAULT_KEYS;
const pressed=new Set();
addEventListener('keydown',e=>{
  pressed.add(e.key.toLowerCase());
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
});
addEventListener('keyup',e=>pressed.delete(e.key.toLowerCase()));
const isDown=n=>(KEY_MAP[n]||[]).some(k=>pressed.has(k));

/* ================================ Audio =================================== */
const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
function ensureAudio(){ if(audioCtx.state==='suspended') audioCtx.resume(); }
function gainNode(vol){ const g=audioCtx.createGain(); g.gain.value=vol; return g; }
function osc(type,f){ const o=audioCtx.createOscillator(); o.type=type; o.frequency.value=f; return o; }
function noiseBuffer(sec=0.1){ const sr=audioCtx.sampleRate, len=Math.floor(sr*sec), buf=audioCtx.createBuffer(1,len,sr), data=buf.getChannelData(0); for(let i=0;i<len;i++) data[i]=Math.random()*2-1; return buf; }
function env(duration=0.2, peak=0.35){
  const g=gainNode(GAME_CONFIG.audio.master*GAME_CONFIG.audio.musicVol*peak);
  const t=audioCtx.currentTime; g.gain.setValueAtTime(0,t);
  g.gain.linearRampToValueAtTime(g.gain.value, t+0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, t+duration);
  return g;
}
function sfxBeep(type='sine',f=440,d=0.08,g=0.12){
  if(!GAME_CONFIG.audio.soundOn) return; ensureAudio();
  const t=audioCtx.currentTime,o=osc(type,f),gg=gainNode(GAME_CONFIG.audio.master*g);
  o.connect(gg).connect(audioCtx.destination); o.start(); o.stop(t+d);
}
const SFX={ punch:()=>sfxBeep('square',260+Math.random()*60,0.05,0.22),
  hit:()=>sfxBeep('triangle',140,0.08,0.24),
  block:()=>sfxBeep('sine',260,0.06,0.16),
  dodge:()=>sfxBeep('sawtooth',300,0.05,0.16),
  superR:()=>sfxBeep('sine',900,0.13,0.24),
  bell:()=>sfxBeep('sine',660,0.25,0.30),
  ko:()=>sfxBeep('triangle',120,0.36,0.34),
  ui:()=>sfxBeep('sine',520,0.06,0.16) };

/* ============================ Announcer Voice ============================== */
function speak(text, opts={}) {
  try{
    if ('speechSynthesis' in window) {
      ensureAudio();
      const u=new SpeechSynthesisUtterance(text);
      u.pitch=opts.pitch??0.8; u.rate=opts.rate??0.95; u.volume=opts.volume??0.9;
      const v=(speechSynthesis.getVoices()||[]).find(v=>/en/i.test(v.lang))||null; if(v) u.voice=v;
      speechSynthesis.cancel(); speechSynthesis.speak(u);
      return;
    }
  }catch(e){}
  // Fallback: short triad stabs
  const t=audioCtx.currentTime; const base=140;
  [['sawtooth',base*1.0],['square',base*1.26],['sine',base*1.5]].forEach((cfg,i)=>{
    const o=osc(cfg[0],cfg[1]); const g=env(0.25,0.35); o.connect(g).connect(audioCtx.destination);
    o.start(t+i*0.02); o.stop(t+0.25+i*0.02);
  });
}

/* ================================= Music ================================== */
let musicTimer=null, currentTrack=GAME_CONFIG.audio.track;
function stopMusic(){ if(musicTimer){ clearInterval(musicTimer); musicTimer=null; } }
function scheduleBeat(name){
  if(!GAME_CONFIG.audio.musicOn) return; ensureAudio();
  const BPM = name==='Dark Arena'? 96 : (name==='Dojo Drive'? 118 : 124);
  const beatMs = 60000/BPM; stopMusic();
  musicTimer=setInterval(()=>{
    const t=audioCtx.currentTime;
    const kick=(tt)=>{ const o=osc('sine',150); const g=env(0.25,0.42); o.connect(g).connect(audioCtx.destination);
      o.frequency.exponentialRampToValueAtTime(55,tt+0.25); o.start(tt); o.stop(tt+0.26); };
    const sn=(tt)=>{ const n=audioCtx.createBufferSource(); n.buffer=noiseBuffer(0.12);
      const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; const g=env(0.16,0.32);
      n.connect(bp).connect(g).connect(audioCtx.destination); n.start(tt); };
    const hh=(tt)=>{ const n=audioCtx.createBufferSource(); n.buffer=noiseBuffer(0.05);
      const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=4000; const g=env(0.05,0.18);
      n.connect(hp).connect(g).connect(audioCtx.destination); n.start(tt); };

    kick(t); sn(t+beatMs/1000); kick(t+2*beatMs/1000); sn(t+3*beatMs/1000);
    for(let i=0;i<8;i++) hh(t+i*beatMs/2000);

    const root = name==='Dark Arena'? 55 : (name==='Dojo Drive'? 62 : 67);
    const chord=(tt,ns)=>{ const g=env(0.9,0.18); const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200; g.connect(audioCtx.destination);
      ns.forEach(n=>{const o=osc('triangle',n); o.connect(lp).connect(g); o.start(tt); o.stop(tt+0.9);});};
    chord(t,[root,root+7,root+10]); chord(t+2*beatMs/1000,[root-2,root+5,root+9]);

    const bass=(tt,f)=>{ const o=osc('square',f); const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=600; const g=env(0.28,0.22);
      o.connect(lp).connect(g).connect(audioCtx.destination); o.start(tt); o.stop(tt+0.28); };
    bass(t,root); bass(t+beatMs/2000,root-3); bass(t+beatMs/1000,root-5); bass(t+beatMs*0.75/1000,root-7);
  }, beatMs);
}
function startMusic(name){ currentTrack=name; stopMusic(); if(GAME_CONFIG.audio.soundOn && GAME_CONFIG.audio.musicOn) scheduleBeat(name); }
function roundStinger(){
  ensureAudio(); const t=audioCtx.currentTime;
  const o=osc('sine',900); const g=gainNode(GAME_CONFIG.audio.master*0.5); o.connect(g).connect(audioCtx.destination);
  o.frequency.exponentialRampToValueAtTime(220,t+0.6); g.gain.setValueAtTime(0.0001,t+0.7); o.start(t); o.stop(t+0.72);
  const seq=[440,554,659]; seq.forEach((f,i)=>{ const oo=osc('square',f); const gg=env(0.14,0.28); oo.connect(gg).connect(audioCtx.destination);
    oo.start(t+0.72+i*0.12); oo.stop(t+0.82+i*0.12); });
}

/* =============================== Rendering ================================ */
const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
function roundedRect(x,y,w,h,r,fill=true,strokeCol=null){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); if(fill) ctx.fill(); if(strokeCol){ ctx.lineWidth=2.2; ctx.strokeStyle=strokeCol; ctx.stroke(); }
}

/* ================================= Entities =============================== */
class Fighter{
  constructor(name,x,flip,isCPU,base,skin){
    const sc=skin.scale||{height:1,arm:1,torso:1};
    Object.assign(this,{
      name,x,y:GAME_CONFIG.canvas.groundY,flip,isCPU, skin:JSON.parse(JSON.stringify(skin)), scale:sc,
      w:Math.round(base.width*sc.torso), h:Math.round(base.height*sc.height),
      health:base.maxHealth,maxHealth:base.maxHealth, stamina:base.maxStamina,maxStamina:base.maxStamina,
      super:0,maxSuper:base.maxSuper,state:'idle',hitting:false,lastDash:-9999,
      move:{kind:null,t:0,window:0,_hit:false}, hitstunUntil:0,dodgeUntil:0, blockUntil:0,
      gaitPhase:0, vy:0, airborne:false, rollUntil:0,
      acc:{swings:0,hits:0,combos:0}, _nextAfterimage:0
    });
  }
  rect(){return {x:this.x-this.w/2,y:this.y-this.h,w:this.w,h:this.h};}
  canAct(t){return t>this.hitstunUntil && t>this.dodgeUntil && t>this.rollUntil && !this.hitting;}
}
function aabb(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;}

class SimpleAI{
  constructor(f,diff){this.f=f;this.diff=diff;this.state='idle';this.nextThink=0;}
  think(t,p,dist){
    if(t<this.nextThink)return;
    this.nextThink=t+120+rand(-60,80);
    const d=this.diff,f=this.f; const low=f.stamina<25, aggro=p.move.kind?1:0;
    const wantDef=chance(0.25*d.aiDefend)||low||aggro;
    const wantAtk=chance(0.35*d.aiAggro)&&!wantDef;
    if(dist>150&&wantAtk){this.state='approach';return;}
    if(dist<70&&wantDef){this.state=chance(0.5)?'defend':'retreat';return;}
    if(wantAtk&&f.canAct(t)&&f.stamina>12){
      const r=srandom();
      this.state = r<0.30?'attack_teep' :
                   r<0.55?'attack_roundhouse' :
                   r<0.75?'attack_shoryu' :
                   (r<0.90?'attack_hook':'attack_jab');
      return;
    }
    this.state=low?'retreat':'idle';
  }
  update(t,p){
    const f=this.f, dist=Math.abs(p.x-f.x), dir=Math.sign(p.x-f.x);
    this.think(t,p,dist);
    const gait=gaitSpeedFactor(f);
    switch(this.state){
      case'approach': f.x+=dir*GAME_CONFIG.enemy.moveSpeed*this.diff.enemySpeed*gait; f.gaitPhase=(f.gaitPhase+GAME_CONFIG.enemy.gaitSpeed)%1; break;
      case'retreat':  f.x-=dir*(GAME_CONFIG.enemy.moveSpeed*0.9)*gait; f.gaitPhase=(f.gaitPhase+GAME_CONFIG.enemy.gaitSpeed)%1; break;
      case'defend':   if(chance(0.6*this.diff.aiDefend)&&f.canAct(t)) startBlock(f,t);
                      else if(chance(0.35*this.diff.aiDefend)&&f.canAct(t)) startDodge(f,t); break;
      case'attack_teep': if(dist<110&&f.canAct(t)) startMove(f,'teep',t,true); else this.state='approach'; break;
      case'attack_roundhouse': if(dist<120&&f.canAct(t)) startMove(f,'roundhouse',t,true); else this.state='approach'; break;
      case'attack_shoryu': if(dist<90&&f.canAct(t)) startMove(f,'shoryu',t,true); else this.state='approach'; break;
      case'attack_hook': if(dist<90&&f.canAct(t)) startMove(f,'hook',t,true); else this.state='approach'; break;
      case'attack_jab': if(dist<90&&f.canAct(t)) startMove(f,'jab',t,true); else this.state='approach'; break;
      default: f.x+=rand(-0.4,0.4);
    }
  }
}

/* ================================== Pets ================================== */
class Pet{
  constructor(type='None'){this.type=type;this.x=0;this.y=GAME_CONFIG.canvas.groundY;this.vy=0;this.cheerUntil=0;this.bobSeed=Math.random()*1000;}
  get enabled(){return this.type!=='None';}
  placeAtPlayer(p){this.x=p.x+GAME_CONFIG.pets.offsetX; this.y=GAME_CONFIG.canvas.groundY;}
  triggerCheer(){const t=nowMs(); this.cheerUntil=t+GAME_CONFIG.pets.cheerMs; if(Math.abs(this.vy)<0.1) this.vy=GAME_CONFIG.pets.hopVY;}
  update(dt,player){
    if(!this.enabled) return;
    const targetX=player.x+GAME_CONFIG.pets.offsetX; this.x += (targetX-this.x)*GAME_CONFIG.pets.followLerp;
    const onGround=this.y>=GAME_CONFIG.canvas.groundY; if(!onGround) this.vy += GAME_CONFIG.pets.gravity; this.y += this.vy;
    if(this.y>GAME_CONFIG.canvas.groundY){this.y=GAME_CONFIG.canvas.groundY; this.vy=0;}
    if(onGround && nowMs()>this.cheerUntil){ const t=(performance.now()+this.bobSeed)*0.005; this.y=GAME_CONFIG.canvas.groundY - Math.sin(t)*GAME_CONFIG.pets.bobAmp*0.35; }
  }
  render(ctx){ if(!this.enabled) return; const cheering=nowMs()<this.cheerUntil; drawPet(this.type,ctx,this.x,this.y,cheering); }
}

/* =============================== Game State =============================== */
const state={ running:false, paused:false, debug:false, round:1, seconds:GAME_CONFIG.round.seconds, sudden:false,
  lastTick:performance.now(), acc:0, step:GAME_CONFIG.timing.stepMs,
  stats:{player:{swings:0,hits:0,damage:0,combos:0},enemy:{swings:0,hits:0,damage:0,combos:0}},
  particles:[], afterimages:[], stars:[], speedlines:[], difficulty:'Normal'
};
let player=null, enemy=null, ai=null, pet=null;

/* =============================== HUD Refs ================================= */
const pHealth=document.getElementById('pHealth'), pStamina=document.getElementById('pStamina'), pSuper=document.getElementById('pSuper');
const eHealth=document.getElementById('eHealth'), eStamina=document.getElementById('eStamina'), eSuper=document.getElementById('eSuper');

/* ================================= Skins ================================== */
function clone(o){return JSON.parse(JSON.stringify(o));}
let SKIN_PLAYER=JSON.parse(localStorage.getItem('bb_skin_player')||'null')||clone(GAME_CONFIG.skins.defaults.player);
let SKIN_CPU   =JSON.parse(localStorage.getItem('bb_skin_cpu')||'null')||clone(GAME_CONFIG.skins.defaults.cpu);

/* ============================== Combat Core =============================== */
function startMove(f,kind,t,isEnemy=false){
  const M=GAME_CONFIG.moves[kind]; if(!M) return;
  // roll (iframes + afterimage burst)
  if(M.roll){
    if(f.stamina<M.stamina) return;
    f.stamina=Math.max(0,f.stamina-M.stamina);
    f.rollUntil=t+M.active; f.dodgeUntil=f.rollUntil;
    const dir=f.flip?-1:1; f.x+=dir*60; leaveAfterimage(f,t);
    return;
  }
  if(f.stamina<M.stamina) return;
  f.hitting=true; f.move={kind,t,window:t+(f.isCPU?GAME_CONFIG.enemy.comboWindowMs:GAME_CONFIG.player.comboWindowMs),_hit:false};
  f.acc.swings++; (f.isCPU?state.stats.enemy:state.stats.player).swings++;
  f.stamina=Math.max(0,f.stamina-M.stamina); SFX.punch();
  if(!f.isCPU && pet?.enabled) pet.triggerCheer();
  if(kind==='shoryu'){ f.vy=-5.6; f.airborne=true; f.dodgeUntil=t+(GAME_CONFIG.moves.shoryu.iframes||0); }
  if(kind==='roundhouse'){ spawnSpinTrail(f); }
  if(kind==='super'){ spawnSpeedlines(f); }
}
function startBlock(f,t){ f.state='block'; f.blockUntil=t+240; SFX.block(); }
function startDodge(f,t){ f.state='dodge'; f.dodgeUntil=t+(f.isCPU?GAME_CONFIG.enemy.dodgeIFrames:GAME_CONFIG.player.dodgeIFrames); SFX.dodge(); }
function startSuper(f,t){ if(f.super<f.maxSuper) return; f.super=0; startMove(f,'super',t,f.isCPU); SFX.superR(); }

function movePhase(f,t){ const m=f.move; if(!m||!m.kind) return null; const M=GAME_CONFIG.moves[m.kind]; const e=t-m.t; const total=M.startup+M.active+M.recovery; if(e<=0)return 0; if(e>=total)return 1; return e/total; }
function gaitSpeedFactor(f){ const s=Math.sin(f.gaitPhase*2*Math.PI); return Math.max(GAME_CONFIG.gait.minFactor,1+GAME_CONFIG.gait.stepBoost*s); }

function computePose(f,t){
  const phase=movePhase(f,t), facing=f.flip?-1:1, bob=Math.sin(t*0.005 + (f.isCPU?1.2:0))*2, gait=Math.sin(f.gaitPhase*2*Math.PI), gaitOpp=Math.sin(f.gaitPhase*2*Math.PI+Math.PI);
  let torsoLean=0, torsoTwist=0;
  let frontUpper=facing*0.15 + gaitOpp*0.12*facing, frontFore=facing*0.25, backUpper=facing*-0.15 + gait*0.12*facing, backFore=facing*-0.10;
  let frontHip=-gait*0.25, frontKnee=Math.max(0,gait)*0.5, backHip=gait*0.25, backKnee=Math.max(0,-gait)*0.5;

  if(f.state==='block'){ frontUpper=facing*-0.35; frontFore=facing*-0.45; backUpper=facing*-0.55; torsoLean=-0.08; }
  if(t<f.dodgeUntil){ torsoLean=-0.25; torsoTwist=-facing*0.15; }

  if(phase!==null){
    const kind=f.move.kind, M=GAME_CONFIG.moves[kind], total=M.startup+M.active+M.recovery;
    const s=M.startup/total, a=(M.startup+M.active)/total; let p; if(phase<=s)p=phase/s; else if(phase<=a)p=1; else p=1-(phase-a)/(1-a);
    const MAX={jab:{arm:1.15,twist:0.14,lean:0.10},hook:{arm:1.6,twist:0.28,lean:0.12},upper:{arm:1.9,twist:0.20,lean:0.18},super:{arm:2.1,twist:0.32,lean:0.24}}[kind]||{arm:1.2,twist:0.2,lean:0.12};
    if(!M.type){ // punches
      frontUpper=facing*(0.1 + MAX.arm*0.6*p); frontFore=facing*(0.25 + MAX.arm*0.4*p);
      backUpper=facing*(-0.25 + 0.3*p); backFore=facing*(-0.15 + 0.25*p);
      torsoTwist=facing*(MAX.twist*p); torsoLean=0.02 + MAX.lean*p; if(kind==='upper'){frontUpper-=facing*0.35*p; frontFore+=facing*0.15*p;} if(kind==='hook'){frontFore+=facing*0.25*p;}
    }
    if(M.type==='kick'){ // kicks
      torsoTwist=facing*(0.25*p)*(kind==='roundhouse'?1.4:1.0); torsoLean=0.06+0.12*p;
      if(kind==='teep'){ frontHip = -0.3 + 1.2*p; frontKnee = 1.1*p; }
      if(kind==='roundhouse'){ frontHip = 0.4 + 1.6*p*(f.flip?-1:1); frontKnee = 0.9; }
      frontUpper=facing*(-0.1); frontFore=facing*(-0.2); backUpper=facing*(0.2); backFore=facing*(0.3);
    }
    if(kind==='shoryu'){ torsoLean=0.22*p; frontUpper=facing*(0.4+1.8*p); frontFore=facing*(0.5+0.6*p); backUpper=facing*(-0.2+0.4*p); }
  }
  return {bob,torsoLean,torsoTwist,frontUpper,frontFore,backUpper,backFore,frontHip,frontKnee,backHip,backKnee};
}

function armJoints(f,which,t){
  const facing=f.flip?-1:1, pose=computePose(f,t);
  const waistX=f.x, waistY=f.y - f.h*0.5 + pose.bob;
  const torsoW=f.w, torsoH=50*f.scale.torso, shoulderY=-torsoH/2+26;
  const shoulderX=(which==='front'?(facing>0? +torsoW/2 : -torsoW/2):(facing>0? -torsoW/2 : +torsoW/2));
  const rotTorso=pose.torsoLean*facing + pose.torsoTwist, cosT=Math.cos(rotTorso), sinT=Math.sin(rotTorso);
  const sx=waistX + (shoulderX*cosT - shoulderY*sinT), sy=waistY + (shoulderX*sinT + shoulderY*cosT);
  const upper=which==='front'?pose.frontUpper:pose.backUpper, fore=which==='front'?pose.frontFore:pose.backFore;
  const armLen1=26*f.scale.arm, armLen2=22*f.scale.arm;
  const a1=rotTorso+upper, ex=sx+Math.cos(a1)*armLen1, ey=sy+Math.sin(a1)*armLen1;
  const a2=a1+fore*0.8, gx=ex+Math.cos(a2)*armLen2, gy=ey+Math.sin(a2)*armLen2;
  return {shoulder:{x:sx,y:sy}, elbow:{x:ex,y:ey}, glove:{x:gx,y:gy}};
}
function armSegmentBoxes(f,which,t){
  const j=armJoints(f,which,t), up=GAME_CONFIG.hitbox.upperBox, fo=GAME_CONFIG.hitbox.foreBox;
  const midUpper={x:(j.shoulder.x+j.elbow.x)/2,y:(j.shoulder.y+j.elbow.y)/2}, midFore={x:(j.elbow.x+j.glove.x)/2,y:(j.elbow.y+j.glove.y)/2};
  return {upperBox:{x:midUpper.x-up.w/2,y:midUpper.y-up.h/2,w:up.w,h:up.h}, foreBox:{x:midFore.x-fo.w/2,y:midFore.y-fo.h/2,w:fo.w,h:fo.h}};
}
function footHitbox(f,t){
  const pose=computePose(f,t), facing=f.flip?-1:1; const M=GAME_CONFIG.moves[f.move?.kind]||{};
  const reach = M.range || 70; const px=f.x + facing*(reach*0.6); const py=f.y-40 + (M.spin? -6:0);
  return {x:px-GAME_CONFIG.hitbox.foot.w/2, y:py-GAME_CONFIG.hitbox.foot.h/2, w:GAME_CONFIG.hitbox.foot.w, h:GAME_CONFIG.hitbox.foot.h};
}

function applyHit(att,vic,baseDmg,knock,t,scale=1){
  if(t<vic.dodgeUntil || t<vic.rollUntil) return;
  let dealt=Math.round(baseDmg*scale); const cfg=vic.isCPU?GAME_CONFIG.enemy:GAME_CONFIG.player;
  if(vic.state==='block'){ dealt=Math.round(dealt*(1-cfg.blockMitigation)); SFX.block(); } else SFX.hit();
  vic.health=Math.max(0,vic.health-dealt);
  (att.isCPU?state.stats.enemy:state.stats.player).damage+=dealt;
  (att.isCPU?state.stats.enemy:state.stats.player).hits++;
  att.super=clamp(att.super+(att.isCPU?GAME_CONFIG.enemy.superGainOnHit:GAME_CONFIG.player.superGainOnHit),0,att.maxSuper);
  vic.super=clamp(vic.super+(vic.isCPU?GAME_CONFIG.enemy.superGainOnBlock:GAME_CONFIG.player.superGainOnBlock),0,vic.maxSuper);
  const push=(att.isCPU?GAME_CONFIG.enemy.pushback:GAME_CONFIG.player.pushback)*knock*(att.flip?-1:1); vic.x+=push*8;
  vic.hitstunUntil=t+(vic.isCPU?GAME_CONFIG.enemy.hitstunMs:GAME_CONFIG.player.hitstunMs);
  spawnStunStars(vic);
  if(vic.health<=0) SFX.ko();
}

/* =================================== FX =================================== */
function spawnSpark(x,y){ state.particles.push({x,y,dx:rand(-1,1),dy:rand(-2,-0.4),life:260}); }
function spawnSpeedlines(f){ for(let i=0;i<GAME_CONFIG.fx.speedlines.count;i++){ state.speedlines.push({x:f.x+(f.flip?-1:1)*rand(8,18), y:f.y-rand(80,120), vx:(f.flip?-1:1)*rand(6,10), life:GAME_CONFIG.fx.speedlines.life}); } }
function spawnSpinTrail(f){ for(let i=0;i<12;i++){ state.particles.push({x:f.x,y:f.y-60,dx:(f.flip?-1:1)*rand(1,3),dy:rand(-2,2),life:220}); } }
function leaveAfterimage(f,t){ if(t<f._nextAfterimage) return; f._nextAfterimage=t+GAME_CONFIG.fx.afterimage.spawnEveryMs; const pose=computePose(f,t); state.afterimages.push({x:f.x,y:f.y,w:f.w,h:f.h,flip:f.flip,isCPU:f.isCPU,pose,skin:clone(f.skin),life:GAME_CONFIG.fx.afterimage.life,alpha:GAME_CONFIG.fx.afterimage.alpha,scale:clone(f.scale)}); }
function spawnStunStars(f){ const head={x:f.x,y:f.y-f.h+22}; for(let i=0;i<GAME_CONFIG.fx.stars.count;i++){ state.stars.push({x:head.x,y:head.y,angle:(i/GAME_CONFIG.fx.stars.count)*Math.PI*2,radius:GAME_CONFIG.fx.stars.radius,life:GAME_CONFIG.fx.stars.life,t:0}); } }

/* ============================== Background ================================ */
function renderBackgroundPanda(w,h){
  ctx.save();
  const t=performance.now()/1000;
  const sky=ctx.createLinearGradient(0,0,0,h); sky.addColorStop(0,'#ffdf9e'); sky.addColorStop(0.4,'#ffb77e'); sky.addColorStop(1,'#1a1d29'); ctx.fillStyle=sky; ctx.fillRect(0,0,w,h);
  const sunX=w*0.68, sunY=h*0.22, sunR=56; ctx.globalAlpha=0.9; ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(sunX,sunY,sunR,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=0.2; ctx.beginPath(); ctx.arc(sunX,sunY,sunR*1.8,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  drawMountains(3,h*0.58,'#2a2d3d',0.15,0.003,0.8); drawMountains(2,h*0.66,'#202334',0.22,0.004,0.9); drawMountains(1,h*0.74,'#161a2a',0.30,0.006,1.0);
  drawBambooWall('left',14,w*0.08,h,t); drawBambooWall('right',14,w*0.92,h,t);
  ctx.fillStyle='#1c2030'; ctx.fillRect(60, GAME_CONFIG.canvas.groundY-10, w-120, 20);
  ctx.restore();
}
function drawMountains(layers,baseY,color,amp,speed,scaleX){
  ctx.save(); const t=performance.now()*speed; ctx.fillStyle=color;
  for(let L=0;L<layers;L++){
    ctx.beginPath(); const y=baseY+L*16; ctx.moveTo(0,y);
    for(let x=0;x<=960;x+=32){ const n=Math.sin((x*scaleX+t*0.04)+L)*amp*60 + Math.cos((x*scaleX*0.6+t*0.03)-L)*amp*30; ctx.lineTo(x,y-n); }
    ctx.lineTo(960,540); ctx.lineTo(0,540); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}
function drawBambooWall(side,count,anchorX,h,t){
  ctx.save(); const sway=Math.sin(t*1.2)*0.06;
  for(let i=0;i<count;i++){
    const off=(i/(count-1))*120-60; const x=side==='left'?anchorX+off:anchorX-off;
    const height=220+(i%5)*14; drawSingleBamboo(x,h*0.60,height,sway*(0.6+(i%3)*0.15));
  }
  ctx.restore();
}
function drawSingleBamboo(x,baseY,height,angle){
  ctx.save(); ctx.translate(x,baseY); ctx.rotate(angle);
  const w=10, seg=18, segH=Math.max(8,height/seg);
  for(let s=0;s<seg;s++){ const y=-s*segH;
    const g=ctx.createLinearGradient(-w/2,y,w/2,y); g.addColorStop(0,'#0b2e1f'); g.addColorStop(0.5,'#145c3e'); g.addColorStop(1,'#0b2e1f');
    ctx.fillStyle=g; roundedRect(-w/2,y-segH,w,segH,4,true);
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(-w/2,y-segH-1,w,2);
  }
  for(let k=0;k<5;k++){ ctx.save(); ctx.translate(0,-height*0.2 - k*height*0.15); ctx.rotate(-0.6 + k*0.25);
    ctx.fillStyle='rgba(49,201,120,0.8)'; ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(28,-6,46,0); ctx.quadraticCurveTo(28,6,0,0); ctx.fill(); ctx.restore(); }
  ctx.restore();
}

/* ========================== Draw Fighters & Pets ========================== */
function drawFace(headW,torsoH,kind){
  ctx.save(); ctx.translate(0,-torsoH/2 - headW*0.22); ctx.fillStyle='#111';
  roundedRect(-headW*0.26,-4,6,6,2,true); roundedRect(+headW*0.20,-4,6,6,2,true);
  if(kind==='determined'){ roundedRect(-8,6,16,2,1,true);} else { ctx.fillRect(-6,6,12,2); }
  ctx.restore();
}
function drawArm(sx,sy,upper,fore,skin,glove,wrap){
  const arm1=26, arm2=22, th=18; ctx.save(); ctx.translate(sx,sy); ctx.rotate(upper);
  const g1=ctx.createLinearGradient(0,-th/2,0,th/2); g1.addColorStop(0,shade(skin,1.05)); g1.addColorStop(1,shade(skin,0.65));
  ctx.fillStyle=g1; roundedRect(0,-th/2,arm1,th,8,true,'#0a0b12'); ctx.fillStyle=wrap; roundedRect(arm1*0.35,-th/2,10,th,4,true);
  ctx.translate(arm1,0); ctx.rotate(fore*0.8);
  const g2=ctx.createLinearGradient(0,-th/2,0,th/2); g2.addColorStop(0,shade(skin,1.02)); g2.addColorStop(1,shade(skin,0.65));
  ctx.fillStyle=g2; roundedRect(0,-th/2,arm2,th,8,true,'#0a0b12');
  const gg=ctx.createLinearGradient(0,-th/2,0,th/2); gg.addColorStop(0,shade('#ffd166',1.08)); gg.addColorStop(1,shade('#ffd166',0.7));
  ctx.fillStyle=gg; roundedRect(arm2-2,-th/2+6,18,12,6,true,'#0a0b12');
  ctx.restore();
}
function drawLeg(hx,baseY,hip,knee,color){
  const th=16, upper=26, lower=22; ctx.save(); ctx.translate(hx,baseY); ctx.rotate(hip);
  const g1=ctx.createLinearGradient(-th/2,0,th/2,0); g1.addColorStop(0,shade(color,1.1)); g1.addColorStop(1,shade(color,0.65)); ctx.fillStyle=g1; roundedRect(-th/2,0,th,upper,7,true,'#0a0b12');
  ctx.translate(0,upper); ctx.rotate(knee);
  const g2=ctx.createLinearGradient(-th/2,0,th/2,0); g2.addColorStop(0,shade(color,1.06)); g2.addColorStop(1,shade(color,0.65)); ctx.fillStyle=g2; roundedRect(-th/2,0,th,lower,7,true,'#0a0b12');
  ctx.restore();
}
function drawFighter(f,isGhost=false){
  const t=performance.now(), pose=computePose(f,t);
  const waistX=f.x, waistY=f.y - f.h*0.5 + pose.bob, s=f.skin, sc=f.scale;
  ctx.globalAlpha=isGhost?0.15:0.3; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(f.x,f.y-4,30,8,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;

  ctx.save(); ctx.translate(waistX,waistY); ctx.rotate(pose.torsoLean*(f.flip?-1:1)+pose.torsoTwist);
  const torsoW=f.w, torsoH=50*sc.torso, headW=f.w-12, headH=24*sc.torso;

  // legs
  drawLeg(-torsoW*0.25,+f.h*0.5-36,pose.backHip,pose.backKnee,s.pant);
  drawLeg(+torsoW*0.25,+f.h*0.5-36,pose.frontHip,pose.frontKnee,s.pant);

  // torso
  const torsoGrad=ctx.createLinearGradient(0,-torsoH/2,0,torsoH/2);
  torsoGrad.addColorStop(0,shade(s.top,1.10)); torsoGrad.addColorStop(0.7,s.top); torsoGrad.addColorStop(1,shade(s.top,0.65));
  ctx.fillStyle=torsoGrad; roundedRect(-torsoW/2,-torsoH/2,torsoW,torsoH,8,true,'#0a0b12');

  // head
  const headGrad=ctx.createLinearGradient(0,-torsoH/2-headH,0,-torsoH/2);
  headGrad.addColorStop(0,shade(s.skin,1.02)); headGrad.addColorStop(1,shade(s.skin,0.65));
  ctx.fillStyle=headGrad; roundedRect(-headW/2,-torsoH/2-headH,headW,headH,6,true,'#0a0b12');
  ctx.globalAlpha=0.18; ctx.fillStyle='#fff'; roundedRect(-headW*0.25,-torsoH/2-headH+4,headW*0.22,headH*0.25,4,true); ctx.globalAlpha=1;
  drawFace(headW,torsoH,s.face);

  // arms
  const shoulderY=-torsoH/2+26, shoulderFront=(f.flip? -torsoW/2 : +torsoW/2), shoulderBack=-shoulderFront;
  drawArm(shoulderBack,shoulderY,pose.backUpper,pose.backFore,s.skin,s.glove,s.wrap);
  drawArm(shoulderFront,shoulderY,pose.frontUpper,pose.frontFore,s.skin,s.glove,s.wrap);
  ctx.restore();

  // optional foot hitbox debug (kicks)
  if(f.hitting && GAME_CONFIG.moves[f.move.kind]?.type==='kick' && !isGhost){
    const fb=footHitbox(f,performance.now()); ctx.strokeStyle='#9bb8ff55'; ctx.strokeRect(fb.x,fb.y,fb.w,fb.h);
  }
}
function drawPet(type,ctx,x,y,cheer){
  switch(type){
    case 'Panda': return drawPetPanda(ctx,x,y,cheer);
    case 'Fox': return drawPetFox(ctx,x,y,cheer);
    case 'Boston Terrier': return drawPetDog(ctx,x,y,cheer,true);
    case 'French Bulldog': return drawPetDog(ctx,x,y,cheer,false);
    case 'Crab': return drawPetCrab(ctx,x,y,cheer);
    default: return;
  }
}
function drawPetPanda(ctx,x,y,cheer){
  const base=y-6; ctx.globalAlpha=0.2; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y-2,20,6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle='#fff'; roundedRect(x-18,base-28,36,30,14,true); ctx.fillStyle='#111'; roundedRect(x-18,base-16,36,18,12,true);
  ctx.fillStyle='#fff'; roundedRect(x-20,base-44,40,28,12,true);
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x-12,base-44,6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+12,base-44,6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#222'; ctx.beginPath(); ctx.ellipse(x-8,base-34,6,7,0.2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x+8,base-34,6,7,-0.2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x-8,base-34,2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+8,base-34,2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#111'; ctx.fillRect(x-1,base-30,2,2); ctx.fillRect(x-4,base-28,8,2);
  const a = cheer? Math.sin(performance.now()*0.02)*0.7 : Math.sin(performance.now()*0.005)*0.3;
  ctx.save(); ctx.translate(x-16,base-20); ctx.rotate(-0.7+a); roundedRect(-3,-3,6,12,3,true); ctx.restore();
  ctx.save(); ctx.translate(x+16,base-20); ctx.rotate(0.7-a);  roundedRect(-3,-3,6,12,3,true); ctx.restore();
}
function drawPetFox(ctx,x,y,cheer){
  const base=y-6; ctx.globalAlpha=0.2; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y-2,18,6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle='#ffb36b'; roundedRect(x-22,base-22,44,24,12,true); ctx.fillStyle='#e67a2e'; roundedRect(x-22,base-10,44,18,10,true);
  ctx.fillStyle='#fff'; roundedRect(x+8,base-18,14,10,5,true);
  ctx.fillStyle='#e67a2e'; ctx.beginPath(); ctx.moveTo(x-14,base-22); ctx.lineTo(x-2,base-32); ctx.lineTo(x+2,base-22); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+14,base-22); ctx.lineTo(x+2,base-32); ctx.lineTo(x-2,base-22); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x-6,base-14,2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+6,base-14,2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.moveTo(x+18,base-8); ctx.lineTo(x+34,base-6); ctx.lineTo(x+18,base-4); ctx.closePath(); ctx.fill();
}
function drawPetDog(ctx,x,y,cheer,boston){
  const base=y-6; const coat=boston?'#222':'#b49c7a'; const mask=boston?'#fff':'#222';
  ctx.globalAlpha=0.2; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y-2,20,6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle=coat; roundedRect(x-20,base-24,40,24,12,true); ctx.fillStyle=coat; roundedRect(x-20,base-12,40,18,10,true);
  ctx.fillStyle=mask; roundedRect(x-8,base-22,16,10,6,true);
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x-6,base-16,2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+6,base-16,2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=coat; ctx.beginPath(); ctx.moveTo(x-12,base-24); ctx.lineTo(x-2,base-34); ctx.lineTo(x+2,base-24); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+12,base-24); ctx.lineTo(x+2,base-34); ctx.lineTo(x-2,base-24); ctx.closePath(); ctx.fill();
}
function drawPetCrab(ctx,x,y,cheer){
  const base=y-2; ctx.globalAlpha=0.2; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y,16,5,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle='#ff6b6b'; roundedRect(x-18,base-12,36,16,8,true);
  for(let i=-1;i<=1;i+=2){ ctx.save(); ctx.translate(x+i*16,base-12); ctx.rotate(i*0.6); roundedRect(-3,-8,6,14,3,true); ctx.restore(); }
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x-6,base-6,2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+6,base-6,2,0,Math.PI*2); ctx.fill();
  for(let i=-2;i<=2;i++){ ctx.fillStyle='#ff6b6b'; roundedRect(x+i*7-2,base+2,4,6,2,true); }
}

/* ================================== HUD =================================== */
function setBars(){
  if(player){ pHealth.style.width=`${(player.health/player.maxHealth)*100}%`; pStamina.style.width=`${(player.stamina/player.maxStamina)*100}%`; pSuper.style.width=`${(player.super/player.maxSuper)*100}%`; }
  else { pHealth.style.width=pStamina.style.width=pSuper.style.width='0%'; }
  if(enemy){ eHealth.style.width=`${(enemy.health/enemy.maxHealth)*100}%`; eStamina.style.width=`${(enemy.stamina/enemy.maxStamina)*100}%`; eSuper.style.width=`${(enemy.super/enemy.maxSuper)*100}%`; }
}

/* ================================ Rounds ================================== */
function spawnFighters(){
  const d=GAME_CONFIG.difficulty[state.difficulty]||GAME_CONFIG.difficulty.Normal;
  player=new Fighter('Player',GAME_CONFIG.canvas.ring.left+140,false,false,GAME_CONFIG.player,SKIN_PLAYER);
  enemy =new Fighter('CPU',   GAME_CONFIG.canvas.ring.right-140,true, true, GAME_CONFIG.enemy, SKIN_CPU);
  enemy.health=enemy.maxHealth=Math.round(GAME_CONFIG.enemy.maxHealth*d.enemyHp);
  ai=new SimpleAI(enemy,d); if(!pet) pet=new Pet(loadPetType()); pet.placeAtPlayer(player);
}
function resetRound(sec=GAME_CONFIG.round.seconds){
  state.seconds=sec; state.sudden=false;
  document.getElementById('roundTag').textContent=`Round ${state.round} / ${GAME_CONFIG.round.bestOf}`;
  document.getElementById('timer').textContent=fmtTime(state.seconds);
  spawnFighters(); SFX.bell();
  // Announcer + stinger + guarantee music
  ensureAudio(); roundStinger();
  setTimeout(()=>speak(`Round ${state.round}!`,{rate:0.9,pitch:0.8}),360);
  setTimeout(()=>speak('Fight!',{rate:1.05,pitch:0.9}),1100);
  if(GAME_CONFIG.audio.musicOn) startMusic(currentTrack);
}

/* ================================= Update ================================= */
function update(dt){
  const t=nowMs(); if(state.paused||!state.running) return;

  // timer
  state._secAcc=(state._secAcc||0)+dt/1000;
  if(state._secAcc>=1){
    state._secAcc=0; state.seconds=Math.max(0,state.seconds-1);
    document.getElementById('timer').textContent=fmtTime(state.seconds);
    if(state.seconds===0){
      if(!state.sudden){ state.sudden=true; state.seconds=GAME_CONFIG.round.suddenDeath; SFX.bell(); }
      else { endRoundByHP(); return; }
    }
  }

  if(player&&enemy){
    // facing
    player.flip = enemy.x<player.x; enemy.flip = player.x<enemy.x;

    // movement & inputs
    const mv=(isDown('left')?-1:0)+(isDown('right')?1:0); const gait=gaitSpeedFactor(player);
    if(player.canAct(t)) player.x += mv*GAME_CONFIG.player.moveSpeed*gait;
    if(mv!==0) player.gaitPhase=(player.gaitPhase+GAME_CONFIG.player.gaitSpeed)%1;

    // step dash
    if(isDown('stepF')&&t>player.lastDash+GAME_CONFIG.player.dashCd && player.canAct(t)){
      player.lastDash=t; const dir=player.flip?-1:1;
      player.x+=dir*(GAME_CONFIG.player.dash*10); player.stamina=Math.max(0,player.stamina-GAME_CONFIG.player.staminaDrainMove);
    }
    if(isDown('stepB')&&t>player.lastDash+GAME_CONFIG.player.dashCd && player.canAct(t)){
      player.lastDash=t; const dir=player.flip?-1:1;
      player.x-=dir*(GAME_CONFIG.player.dash*10); player.stamina=Math.max(0,player.stamina-GAME_CONFIG.player.staminaDrainMove);
    }

    // actions
    if(player.canAct(t)){
      if(isDown('roll')) startMove(player,'roll',t,false);
      else if(isDown('shoryu')) startMove(player,'shoryu',t,false);
      else if(isDown('roundhouse')) startMove(player,'roundhouse',t,false);
      else if(isDown('teep')) startMove(player,'teep',t,false);
      else if(isDown('block')) startBlock(player,t);
      else if(isDown('dodge')) startDodge(player,t);
      else if(isDown('jab')) startMove(player,'jab',t,false);
      else if(isDown('hook')) startMove(player,'hook',t,false);
      else if(isDown('upper')) startMove(player,'upper',t,false);
      else if(isDown('super')) startSuper(player,t);
    } else if(player.state==='block' && t>(player.blockUntil||0)){ player.state='idle'; }

    if(t<player.dodgeUntil || t<player.rollUntil) leaveAfterimage(player,t);

    // gravity
    [player,enemy].forEach(f=>{
      if(f.airborne){ f.vy+=0.35; f.y+=f.vy; if(f.y>=GAME_CONFIG.canvas.groundY){ f.y=GAME_CONFIG.canvas.groundY; f.vy=0; f.airborne=false; } }
    });

    // AI update
    ai.update(t,player,dt); if(t<enemy.dodgeUntil || t<enemy.rollUntil) leaveAfterimage(enemy,t);

    // clamp ring
    const L=GAME_CONFIG.canvas.ring.left,R=GAME_CONFIG.canvas.ring.right;
    player.x=clamp(player.x,L,R); enemy.x=clamp(enemy.x,L,R);

    // stamina regen
    if(!player.hitting && player.state!=='block') player.stamina=clamp(player.stamina+GAME_CONFIG.player.staminaRegen*dt/1000,0,player.maxStamina);
    if(!enemy.hitting && enemy.state!=='block')   enemy.stamina =clamp(enemy.stamina +GAME_CONFIG.enemy.staminaRegen *dt/1000,0,enemy.maxStamina);

    // resolve attacks (multi-segment)
    stepMoveWithSegments(player,enemy,t);
    stepMoveWithSegments(enemy,player,t);

    // KO?
    if(player.health<=0||enemy.health<=0){ endRoundByKO(); }
  }

  if(pet) pet.update(dt,player||{x:GAME_CONFIG.canvas.width/2});

  // FX updates
  for(const s of state.stars){ s.t+=dt; s.life-=dt; }
  state.stars=state.stars.filter(s=>s.life>0);
  for(const p of state.particles){ p.x+=p.dx; p.y+=p.dy; p.dy+=0.03; p.life-=dt; }
  state.particles=state.particles.filter(p=>p.life>0);
  for(const g of state.afterimages){ g.life-=dt; g.alpha*=0.94; }
  state.afterimages=state.afterimages.filter(g=>g.life>0);
  for(const sl of state.speedlines){ sl.x+=sl.vx; sl.life-=dt; }
  state.speedlines=state.speedlines.filter(s=>s.life>0);

  setBars();
}
function stepMoveWithSegments(att,vic,t){
  const m=att.move; if(!m||!m.kind) return; const M=GAME_CONFIG.moves[m.kind]; const elapsed=t-m.t;
  if(elapsed>M.startup && elapsed<M.startup+M.active && !m._hit){
    if(M.type==='kick'){
      const fb=footHitbox(att,t);
      if(vic && aabb(fb,vic.rect())){ applyHit(att,vic,M.dmg,M.knock,t,1.0); spawnSpark(fb.x+fb.w/2,fb.y+fb.h/2); m._hit=true; if(nowMs()<m.window) (att.isCPU?state.stats.enemy:state.stats.player).combos++; }
    }else{
      const {upperBox,foreBox}=armSegmentBoxes(att,'front',t);
      if(vic && aabb(foreBox,vic.rect())){ applyHit(att,vic,M.dmg,M.knock,t,1.0); spawnSpark(foreBox.x+foreBox.w/2,foreBox.y+foreBox.h/2); m._hit=true; if(nowMs()<m.window) (att.isCPU?state.stats.enemy:state.stats.player).combos++; }
      else if(vic && aabb(upperBox,vic.rect())){ applyHit(att,vic,M.dmg,M.knock*0.8,t,0.8); spawnSpark(upperBox.x+upperBox.w/2,upperBox.y+upperBox.h/2); m._hit=true; if(nowMs()<m.window) (att.isCPU?state.stats.enemy:state.stats.player).combos++; }
    }
  }
  if(elapsed>(M.startup+M.active+M.recovery)){ att.hitting=false; att.move={kind:null,t:0,window:0,_hit:false}; }
}

/* ================================= Render ================================= */
function render(){
  ctx.setTransform(1,0,0,1,0,0);
  const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h);
  renderBackgroundPanda(GAME_CONFIG.canvas.width, GAME_CONFIG.canvas.height);

  if(pet) pet.render(ctx);

  for(const g of state.afterimages){ ctx.save(); ctx.globalAlpha=g.alpha; // lightweight ghost render: reuse main draw with ghost flag
    // draw ghost silhouette
    const ghost={x:g.x,y:g.y,w:g.w,h:g.h,flip:g.flip,isCPU:g.isCPU,skin:g.skin,scale:g.scale,move:{kind:null},gaitPhase:0,vy:0,airborne:false};
    drawFighter(ghost,true); ctx.restore();
  }

  if(player&&enemy){ drawFighter(player); drawFighter(enemy); }
  else { ctx.fillStyle='#9bb8ff'; ctx.font='700 20px Arial'; ctx.fillText('Press ‚ñ∂ Play to start', 360, GAME_CONFIG.canvas.groundY-140); }

  for(const s of state.stars){
    const ang=s.angle+s.t*0.02; const rx=s.x+Math.cos(ang)*s.radius; const ry=s.y+Math.sin(ang)*s.radius*0.6;
    drawStar(rx,ry,5,6,3,Math.max(0,s.life/GAME_CONFIG.fx.stars.life));
  }
  for(const p of state.particles){ ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(p.x,p.y,3,3); }
  ctx.strokeStyle='#9bb8ff55'; ctx.lineWidth=2;
  for(const sl of state.speedlines){ ctx.beginPath(); ctx.moveTo(sl.x, sl.y); ctx.lineTo(sl.x-20, sl.y+rand(-6,6)); ctx.stroke(); }

  if(state.debug) drawDebug();
}
function drawStar(cx,cy,points,outerR,innerR,alpha){
  ctx.save(); ctx.globalAlpha=0.9*alpha; ctx.fillStyle='#ffd166'; ctx.beginPath();
  for(let i=0;i<points*2;i++){ const r=(i%2===0)?outerR:innerR; const a=(Math.PI*i)/points;
    const x=cx+Math.cos(a)*r; const y=cy+Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.closePath(); ctx.fill(); ctx.globalAlpha=1; ctx.restore();
}
function drawDebug(){
  ctx.save(); ctx.fillStyle='#fff'; ctx.font='12px monospace';
  ctx.fillText(`AI:${ai?.state||'-'}`, 12, 16);
  if(player){ const b=player.rect(); ctx.strokeStyle='#44ff88aa'; ctx.strokeRect(b.x,b.y,b.w,b.h);}
  if(enemy){ const b=enemy.rect(); ctx.strokeStyle='#ff4488aa'; ctx.strokeRect(b.x,b.y,b.w,b.h);}
  ctx.restore();
}

/* ================================== Loop ================================== */
function loop(ts){
  const dt=ts-(state.lastTick||ts); state.lastTick=ts; state.acc=(state.acc||0)+dt;
  try{ while(state.acc>=state.step){ update(state.step); state.acc-=state.step; } render(); }catch(e){ console.error(e); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =============================== Round End ================================ */
function endRoundByKO(){
  state.paused=true; state.running=false;
  showModal('KO!', resultsHTML((player&&player.health>0)?'You Win!':'CPU Wins!'));
}
function endRoundByHP(){
  state.paused=true; state.running=false;
  const p=player?player.health:0,e=enemy?enemy.health:0;
  showModal('Time!', resultsHTML(p>=e?'You Win (decision)!':'CPU Wins (decision)!'));
}
function resultsHTML(winner){
  const accP=state.stats.player.swings?Math.round(100*state.stats.player.hits/state.stats.player.swings):0;
  const accE=state.stats.enemy.swings?Math.round(100*state.stats.enemy.hits/state.stats.enemy.swings):0;
  return `<div class="grid">
    <div style="font-weight:800;font-size:1.2rem">${winner}</div>
    <div class="grid grid2">
      <div><strong>Player</strong><div>Damage: ${state.stats.player.damage}</div><div>Accuracy: ${accP}%</div><div>Combos: ${state.stats.player.combos}</div></div>
      <div><strong>CPU</strong><div>Damage: ${state.stats.enemy.damage}</div><div>Accuracy: ${accE}%</div><div>Combos: ${state.stats.enemy.combos}</div></div>
    </div>
    <div class="row" style="justify-content:flex-end"><button class="btn" id="btnPlayAgain">Play Again</button></div>
  </div>`;
}

/* ================================= Modal ================================== */
const modal={root:document.getElementById('modalBackdrop'),title:document.getElementById('modalTitle'),body:document.getElementById('modalBody')};
function showModal(title,html){ modal.title.textContent=title; modal.body.innerHTML=html; modal.root.style.display='flex';
  const btn=document.getElementById('btnPlayAgain'); if(btn) btn.onclick=()=>{ closeModal(); startGame(); }; }
function closeModal(){ modal.root.style.display='none'; SFX.ui(); }
document.getElementById('modalClose').addEventListener('click',closeModal);
modal.root.addEventListener('click',e=>{ if(e.target===modal.root) closeModal(); });

/* ================================= Menus ================================== */
// Skins
const btnSkins=document.getElementById('btnSkins');
btnSkins.addEventListener('click',()=>{
  const color=(id,label,val)=>`<label class="row"><span style="width:120px">${label}</span><input id="${id}" type="color" class="select" value="${val}"/></label>`;
  const sel=(id,label,ops,val)=>`<label class="row"><span style="width:120px">${label}</span><select id="${id}" class="select">${ops.map(o=>`<option ${o===val?'selected':''}>${o}</option>`).join('')}</select></label>`;
  const scale=(id,label,val)=>`<label class="row"><span style="width:120px">${label}</span><input id="${id}" type="range" min="0.85" max="1.15" step="0.01" value="${val}" oninput="this.nextElementSibling.textContent=this.value"/><span class="small">${val}</span></label>`;
  const hair=GAME_CONFIG.skins.hair, face=GAME_CONFIG.skins.face, bodyStyle=GAME_CONFIG.skins.body;
  const body=`<div class="grid grid2">
    <div class="card" style="padding:10px"><div><strong>Player</strong></div>
      ${color('pl_skin','Skin',SKIN_PLAYER.skin)} ${color('pl_hair','Hair',SKIN_PLAYER.hair)} ${color('pl_glove','Glove',SKIN_PLAYER.glove)}
      ${color('pl_top','Top',SKIN_PLAYER.top)} ${color('pl_pant','Pants',SKIN_PLAYER.pant)} ${color('pl_wrap','Wrap',SKIN_PLAYER.wrap)}
      ${sel('pl_face','Face',face,SKIN_PLAYER.face)} ${sel('pl_hairStyle','Hair',hair,SKIN_PLAYER.hairStyle)} ${sel('pl_body','Body',bodyStyle,SKIN_PLAYER.bodyStyle||'Human')}
      ${scale('pl_h','Height',SKIN_PLAYER.scale?.height??1)} ${scale('pl_arm','Arm',SKIN_PLAYER.scale?.arm??1)} ${scale('pl_torso','Torso',SKIN_PLAYER.scale?.torso??1)}
      <div class="row" style="justify-content:flex-end"><button id="skinsSave" class="btn">Save</button></div>
    </div>
    <div class="card" style="padding:10px"><div><strong>CPU</strong></div>
      ${color('cpu_skin','Skin',SKIN_CPU.skin)} ${color('cpu_hair','Hair',SKIN_CPU.hair)} ${color('cpu_glove','Glove',SKIN_CPU.glove)}
      ${color('cpu_top','Top',SKIN_CPU.top)} ${color('cpu_pant','Pants',SKIN_CPU.pant)} ${color('cpu_wrap','Wrap',SKIN_CPU.wrap)}
      ${sel('cpu_face','Face',face,SKIN_CPU.face)} ${sel('cpu_hairStyle','Hair',hair,SKIN_CPU.hairStyle)} ${sel('cpu_body','Enemy Body',bodyStyle,SKIN_CPU.bodyStyle||'Human')}
      ${scale('cpu_h','Height',SKIN_CPU.scale?.height??1)} ${scale('cpu_arm','Arm',SKIN_CPU.scale?.arm??1)} ${scale('cpu_torso','Torso',SKIN_CPU.scale?.torso??1)}
    </div></div>`;
  showModal('Skins',body);
  modal.body.querySelector('#skinsSave').addEventListener('click',()=>{
    const g=id=>modal.body.querySelector('#'+id).value;
    SKIN_PLAYER={skin:g('pl_skin'),hair:g('pl_hair'),glove:g('pl_glove'),top:g('pl_top'),pant:g('pl_pant'),wrap:g('pl_wrap'),face:g('pl_face'),hairStyle:g('pl_hairStyle'),bodyStyle:g('pl_body'),scale:{height:+g('pl_h'),arm:+g('pl_arm'),torso:+g('pl_torso')}};
    SKIN_CPU   ={skin:g('cpu_skin'),hair:g('cpu_hair'),glove:g('cpu_glove'),top:g('cpu_top'),pant:g('cpu_pant'),wrap:g('cpu_wrap'),face:g('cpu_face'),hairStyle:g('cpu_hairStyle'),bodyStyle:g('cpu_body'),scale:{height:+g('cpu_h'),arm:+g('cpu_arm'),torso:+g('cpu_torso')}};
    localStorage.setItem('bb_skin_player',JSON.stringify(SKIN_PLAYER));
    localStorage.setItem('bb_skin_cpu',JSON.stringify(SKIN_CPU));
    closeModal();
  });
});

// Pets
function loadPetType(){ const tp=localStorage.getItem('bb_pet_type')||GAME_CONFIG.pets.type; const off=parseInt(localStorage.getItem('bb_pet_offset')||GAME_CONFIG.pets.offsetX,10); GAME_CONFIG.pets.offsetX=off; return tp; }
const btnPets=document.getElementById('btnPets');
btnPets.addEventListener('click',()=>{
  const saved=loadPetType(); const options=GAME_CONFIG.pets.list;
  const body=`<div class="grid">
    <div class="small">Choose a companion (cosmetic only).</div>
    <label class="row"><span style="width:140px">Type</span><select id="petType" class="select">${options.map(o=>`<option ${o===saved?'selected':''}>${o}</option>`).join('')}</select></label>
    <label class="row"><span style="width:140px">Stand Offset</span><input id="petOffset" type="range" min="-150" max="150" step="2" value="${GAME_CONFIG.pets.offsetX}" oninput="this.nextElementSibling.textContent=this.value"/><span class="small">${GAME_CONFIG.pets.offsetX}</span></label>
    <div class="row" style="justify-content:flex-end"><button id="petSave" class="btn">Save</button></div>
  </div>`;
  showModal('Pets',body);
  modal.body.querySelector('#petSave').addEventListener('click',()=>{
    const tp=modal.body.querySelector('#petType').value; GAME_CONFIG.pets.offsetX=parseInt(modal.body.querySelector('#petOffset').value,10);
    localStorage.setItem('bb_pet_type',tp); localStorage.setItem('bb_pet_offset',String(GAME_CONFIG.pets.offsetX));
    if(!pet) pet=new Pet(tp); else pet.type=tp; closeModal();
  });
});

// Music
const btnMusic=document.getElementById('btnMusic');
btnMusic.addEventListener('click',()=>{
  const tracks=['Arcade Rush','Dojo Drive','Dark Arena','Off'];
  const body=`<div class="grid">
    <div class="small">Energetic in-browser music (not copyrighted themes). Turn off if you prefer SFX only.</div>
    <label class="row"><span style="width:140px">Track</span><select id="selTrack" class="select">${tracks.map(t=>`<option ${t===currentTrack?'selected':''}>${t}</option>`).join('')}</select></label>
    <label class="row"><span style="width:140px">Volume</span><input id="musicVol" type="range" min="0" max="1" step="0.01" value="${GAME_CONFIG.audio.musicVol}" oninput="this.nextElementSibling.textContent=this.value"/><span class="small">${GAME_CONFIG.audio.musicVol}</span></label>
    <label class="checkbox"><input id="musicOn" type="checkbox" ${GAME_CONFIG.audio.musicOn?'checked':''}/> Music On</label>
    <div class="row" style="justify-content:flex-end"><button id="musicApply" class="btn">Apply</button></div>
  </div>`;
  showModal('Music',body);
  modal.body.querySelector('#musicApply').addEventListener('click',()=>{
    GAME_CONFIG.audio.musicVol=parseFloat(modal.body.querySelector('#musicVol').value);
    const name=modal.body.querySelector('#selTrack').value; currentTrack=name;
    const on=modal.body.querySelector('#musicOn').checked;
    if(name==='Off'||!on){ GAME_CONFIG.audio.musicOn=false; stopMusic(); } else { GAME_CONFIG.audio.musicOn=true; startMusic(name); }
    closeModal();
  });
});

// Controls
const btnControls=document.getElementById('btnControls');
btnControls.addEventListener('click',()=>{
  const names=Object.keys(KEY_MAP); let html='<div class="grid">';
  for(const n of names){ html+=`<div class="row"><div style="width:160px"><strong>${n}</strong></div><input class="select" data-k="${n}" value="${KEY_MAP[n].join(', ')}"/></div>`; }
  html+=`<hr class="sep"/><div class="row">
    <label class="checkbox"><input id="lockRng" type="checkbox" ${GAME_CONFIG.random.lock?'checked':''}/> Lock AI RNG</label>
    <input id="rngSeed" class="input" value="${GAME_CONFIG.random.seed}" style="width:120px"/>
  </div>
  <div class="row" style="justify-content:flex-end"><button id="saveKeys" class="btn">Save</button></div></div>`;
  showModal('Controls',html);
  modal.body.querySelector('#saveKeys').addEventListener('click',()=>{
    modal.body.querySelectorAll('[data-k]').forEach(i=>{
      const k=i.getAttribute('data-k'); KEY_MAP[k]=i.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
    });
    localStorage.setItem('bb_keys',JSON.stringify(KEY_MAP));
    GAME_CONFIG.random.lock = modal.body.querySelector('#lockRng').checked;
    const seed=parseInt(modal.body.querySelector('#rngSeed').value,10); if(!Number.isNaN(seed)){ GAME_CONFIG.random.seed=seed; srand(seed>>>0); }
    closeModal();
  });
});

// Accessibility
const btnAcc=document.getElementById('btnAccessibility');
btnAcc.addEventListener('click',()=>{
  const body=`<div class="grid">
    <label class="checkbox"><input id="cbPalette" type="checkbox" ${GAME_CONFIG.ui.colorBlind?'checked':''}/> Color-blind friendly bars</label>
    <label class="checkbox"><input id="reduceFlash" type="checkbox" ${GAME_CONFIG.audio.reduceFlashing?'checked':''}/> Reduce flashing / FX intensity</label>
    <label class="checkbox"><input id="muteSfx" type="checkbox" ${GAME_CONFIG.audio.soundOn?'':'checked'}/> Mute SFX</label>
    <div class="row" style="justify-content:flex-end"><button id="accSave" class="btn">Apply</button></div>
  </div>`;
  showModal('Accessibility',body);
  modal.body.querySelector('#accSave').addEventListener('click',()=>{
    GAME_CONFIG.ui.colorBlind = modal.body.querySelector('#cbPalette').checked;
    GAME_CONFIG.audio.reduceFlashing = modal.body.querySelector('#reduceFlash').checked;
    GAME_CONFIG.audio.soundOn = !modal.body.querySelector('#muteSfx').checked;
    applyPalette(); closeModal();
  });
});
function applyPalette(){
  const hF=p=>p.classList.toggle('cb-health',GAME_CONFIG.ui.colorBlind);
  const sF=p=>p.classList.toggle('cb-stamina',GAME_CONFIG.ui.colorBlind);
  const uF=p=>p.classList.toggle('cb-super',GAME_CONFIG.ui.colorBlind);
  [pHealth,eHealth].forEach(hF); [pStamina,eStamina].forEach(sF); [pSuper,eSuper].forEach(uF);
}

/* ============================== Start/Pause ================================ */
function startGame(){
  ensureAudio();
  state.stats={player:{swings:0,hits:0,damage:0,combos:0},enemy:{swings:0,hits:0,damage:0,combos:0}};
  state.round=1; state.sudden=false; state.running=true; state.paused=false;
  resetRound(); if(GAME_CONFIG.audio.musicOn) startMusic(currentTrack);
}
document.getElementById('btnPlay').addEventListener('click',startGame);
document.getElementById('btnPause').addEventListener('click',()=>{ state.paused=!state.paused; SFX.ui(); });
addEventListener('keydown',e=>{
  if(e.key==='p'||e.key==='P') state.paused=!state.paused;
  if(e.key==='/') state.debug=!state.debug;
  if(e.key==='r'||e.key==='R') startGame();
});

/* ============================== Tutorial ================================== */
(function tutorial(){
  if(localStorage.getItem('bb_tutorial_seen')==='1' || !GAME_CONFIG.ui.showTutorialOnFirstRun) return;
  const keys=`A/D ÁßªÂãï„ÄÅW/S Â∞èÊ≠•„ÄÅJ/K/L Êã≥„ÄÅI Ê†ºÊìã„ÄÅO ÈñÉÈÅø„ÄÅH ÂâçË∏¢„ÄÅG Ëø¥ÊóãË∏¢„ÄÅU ÊòáÈæçÊã≥„ÄÅShift ÁøªÊªæ„ÄÅSpace Ë∂ÖÁ¥ö`;
  showModal('Welcome', `<div class="grid"><div class="small">Controls</div><div>${keys}</div><div class="small">‰Ω†ÂèØÂú® Controls/Skins/Pets/Music/Accessibility Èù¢ÊùøË™øÊï¥„ÄÇ</div></div>`);
  localStorage.setItem('bb_tutorial_seen','1');
})();

/* =========================== Initial Scaling ============================== */
applyPalette();
(function scaleToDPR(){
  const dpr=window.devicePixelRatio||1;
  // Keep CSS size constant; scale internal resolution for crispness
  const cssW=GAME_CONFIG.canvas.width, cssH=GAME_CONFIG.canvas.height;
  canvas.width=cssW*dpr; canvas.height=cssH*dpr;
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
})();

</script>
</body>
</html>
