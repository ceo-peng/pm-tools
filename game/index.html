<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Brawl — Kid-Friendly Roblox-Style Boxing</title>
<style>
  /* =========================
     UI THEME (No external CSS)
     ========================= */
  :root{
    --bg:#0e0f13; --panel:#171923; --panel2:#1f2230; --text:#e8ebff;
    --accent:#6ea8fe; --accent2:#7bf1a8; --danger:#ff6b6b; --warn:#ffd166;
    --good:#63e6be; --muted:#a8b0d3;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px;height:100%}
  .title{font-weight:800;letter-spacing:.5px;margin:8px 0 0 0}
  .sub{color:var(--muted);font-size:.95rem;margin-top:-6px}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap}
  .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid #2a2e42;border-radius:14px;box-shadow:0 4px 18px rgba(0,0,0,.25)}
  .hud{display:flex;align-items:center;gap:12px;padding:8px 12px}
  .btn{background:var(--panel2);border:1px solid #2a2e42;border-radius:12px;color:var(--text);padding:10px 14px;font-weight:700;cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  .btn:active{transform:translateY(1px)}
  .select,.toggle{background:var(--panel2);border:1px solid #2a2e42;border-radius:10px;color:var(--text);padding:8px 10px;font-weight:600}
  .k{background:#272a3d;border-radius:8px;padding:3px 6px;border:1px solid #35395a}
  canvas{background:#121420;border-radius:16px;border:1px solid #2a2e42;max-width:100%;height:auto}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .grow{flex:1}
  .bars{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:6px}
  .bar{height:12px;border-radius:8px;background:#2a2e42;position:relative;overflow:hidden}
  .fill{position:absolute;left:0;top:0;bottom:0;border-radius:8px}
  .health{background:linear-gradient(90deg,#ff8a8a,#ff6b6b)}
  .stamina{background:linear-gradient(90deg,#a1ffe7,#63e6be)}
  .super{background:linear-gradient(90deg,#9bb8ff,#6ea8fe)}
  .timer{font-weight:900;font-size:1.1rem;letter-spacing:.5px}
  .roundtag{font-weight:800;color:#9bb8ff}
  .center{display:flex;justify-content:center;align-items:center}
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:5}
  .modal{width:min(680px,92vw);padding:16px}
  .modal h3{margin:.2rem 0 .6rem 0}
  .grid{display:grid;gap:10px}
  .grid2{grid-template-columns:1fr 1fr}
  .small{font-size:.9rem;color:var(--muted)}
  .stat{font-weight:800}
  .footer{color:#8891bb;font-size:.85rem;margin-top:-6px}
</style>
</head>
<body>
<div class="wrap">
  <h1 class="title">🧱 Block Brawl</h1>
  <div class="sub">Roblox-style, kid-friendly boxing • Vanilla JS + Canvas (no libs)</div>

  <!-- Top HUD -->
  <div class="topbar card hud">
    <button id="btnPlay" class="btn">▶ Play</button>
    <div class="row">
      <label>Difficulty</label>
      <select id="selDiff" class="select">
        <option>Easy</option><option selected>Normal</option><option>Hard</option>
      </select>
    </div>
    <button id="btnControls" class="btn">Controls</button>
    <button id="btnAccessibility" class="btn">Accessibility</button>
    <button id="btnPause" class="btn">Pause (P)</button>
    <div class="row">
      <span class="roundtag" id="roundTag">Round 1 / 3</span>
      <span class="timer" id="timer">01:00</span>
    </div>
  </div>

  <!-- HUD bars -->
  <div class="card" style="padding:10px;width:min(980px,96vw)">
    <div class="row" style="justify-content:space-between">
      <div><strong>Player</strong></div>
      <div><strong>CPU</strong></div>
    </div>
    <div class="bars">
      <div class="grid">
        <div class="bar"><div id="pHealth" class="fill health" style="width:0%"></div></div>
        <div class="bar"><div id="pStamina" class="fill stamina" style="width:0%"></div></div>
        <div class="bar"><div id="pSuper"  class="fill super"   style="width:0%"></div></div>
      </div>
      <div class="grid">
        <div class="bar"><div id="eHealth" class="fill health" style="width:0%"></div></div>
        <div class="bar"><div id="eStamina" class="fill stamina" style="width:0%"></div></div>
        <div class="bar"><div id="eSuper"  class="fill super"   style="width:0%"></div></div>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="game" width="960" height="540"></canvas>
  <div class="footer">Tip: Toggle debug overlay with <span class="k">/</span>. Quick restart <span class="k">R</span>. Super when full <span class="k">Space</span>.</div>
</div>

<!-- Modals -->
<div id="modalBackdrop" class="modal-backdrop center">
  <div class="modal card">
    <h3 id="modalTitle">Welcome</h3>
    <div id="modalBody" class="grid"></div>
    <div class="row" style="justify-content:flex-end;margin-top:10px">
      <button id="modalClose" class="btn">OK</button>
    </div>
  </div>
</div>

<script>
/* 
==========================================
README (at top of JS)
------------------------------------------
Block Brawl — a Roblox-style, kid-friendly boxing game.

Controls (default):
- Move: A/D or ←/→
- Step (dash): W/↑ (forward), S/↓ (back)
- Punches: J (Jab), K (Hook), L (Uppercut)
- Defense: I (Block), O (Dodge)
- Super: Space (when meter full)
- Pause: P | Debug: / | Restart: R

Where to tweak difficulty:
- See GAME_CONFIG at the very top of this script:
  - damage, frame data, stamina costs/rates
  - round length, knockdown rules, AI weights
  - per-difficulty multipliers under DIFFICULTY

File structure:
- Single file (index.html). No images/CDNs. Works offline.

Acceptance:
- 60s rounds, best-of-3; Easy is winnable by a 10-year-old;
- Clean, commented code; no console errors.
==========================================
*/

/* ========================
   GAME CONFIG (All knobs)
   ======================== */
const GAME_CONFIG = {
  canvasW: 960, canvasH: 540, groundY: 420,
  ring: { left: 80, right: 880, ropeY: 260 },
  crowd: { layers: 3, amplitude: 3 },
  gravity: 0.8, friction: 0.85,
  player:{
    width:48,height:96, moveSpeed:4.2, dash:6.5, dashCd:420,
    maxHealth:100, maxStamina:100, staminaRegen:14, staminaDrainMove:2,
    blockMitigation:0.6, dodgeIFrames:260, pushback:3.2,
    superGainOnHit:8, superGainOnBlock:4, maxSuper:100,
    comboWindowMs:450, hitstunMs:220
  },
  enemy:{
    width:48,height:96, moveSpeed:3.8, dash:6.0, dashCd:480,
    maxHealth:100, maxStamina:100, staminaRegen:12, staminaDrainMove:2,
    blockMitigation:0.55, dodgeIFrames:220, pushback:3.0,
    superGainOnHit:8, superGainOnBlock:4, maxSuper:100,
    comboWindowMs:420, hitstunMs:200
  },
  moves:{
    jab:{ dmg:8,  stamina:10, range:60, startup:90, active:120, recovery:180, knock:0.6, advantage:0 },
    hook:{ dmg:14, stamina:16, range:58, startup:140,active:110, recovery:220, knock:1.0, advantage:10 },
    upper:{ dmg:20, stamina:22, range:54, startup:180,active:120, recovery:260, knock:1.3, advantage:20 },
    super:{dmg:36, stamina:0,  range:74, startup:220,active:160, recovery:340, knock:1.6, advantage:40 }
  },
  round:{ seconds:60, suddenDeath:15, bestOf:3, koDowns:3 },
  audio:{ master:0.18, reduceFlashing:false, soundOn:true },
  UI:{ colorBlind:false },
  DIFFICULTY:{
    Easy:   { enemyHp:0.9, enemyDmg:0.85, enemySpeed:0.95, aiAggro:0.72, aiDefend:0.85, aiRandom:0.25 },
    Normal: { enemyHp:1.0, enemyDmg:1.0,   enemySpeed:1.0,  aiAggro:0.92, aiDefend:1.0,  aiRandom:0.18 },
    Hard:   { enemyHp:1.15,enemyDmg:1.1,   enemySpeed:1.05, aiAggro:1.12, aiDefend:1.08, aiRandom:0.12 }
  }
};

/* ========================
   UTILS
   ======================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const nowMs = ()=>performance.now();
const rand = (a,b)=>Math.random()*(b-a)+a;
const chance = (p)=>Math.random()<p;
function fmtTime(s){
  s=Math.max(0,Math.floor(s));
  const m = String(Math.floor(s/60)).padStart(2,'0');
  const r = String(s%60).padStart(2,'0');
  return `${m}:${r}`;
}

/* ========================
   INPUT (with remap)
   ======================== */
const DEFAULT_KEYS = {
  left:['a','arrowleft'],
  right:['d','arrowright'],
  stepF:['w','arrowup'],
  stepB:['s','arrowdown'],
  jab:['j'], hook:['k'], upper:['l'],
  block:['i'], dodge:['o'],
  super:[' '],
  pause:['p'],
  debug:['/'],
  restart:['r']
};
let KEY_MAP = JSON.parse(localStorage.getItem('bb_keys')||'null')||DEFAULT_KEYS;
const pressed = new Set();
addEventListener('keydown',e=>{
  pressed.add(e.key.toLowerCase());
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
});
addEventListener('keyup',e=>pressed.delete(e.key.toLowerCase()));
function isDown(name){ const binds=KEY_MAP[name]||[]; return binds.some(k=>pressed.has(k)); }

/* ========================
   AUDIO (WebAudio beeps)
   ======================== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
function beep(type='sine', freq=440, dur=0.08, gain=0.12){
  if(!GAME_CONFIG.audio.soundOn) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type=type; o.frequency.setValueAtTime(freq,t);
  g.gain.value=GAME_CONFIG.audio.master*gain;
  o.connect(g).connect(audioCtx.destination);
  o.start();
  o.stop(t+dur);
}
const SFX = {
  punch: ()=>beep('square', 220+Math.random()*60, 0.05, 0.20),
  hit:   ()=>beep('triangle', 140, 0.08, 0.22),
  block: ()=>beep('sine', 260, 0.06, 0.16),
  dodge: ()=>beep('sawtooth', 300, 0.04, 0.16),
  superR:()=>beep('sine', 900, 0.12, 0.22),
  bell:  ()=>beep('sine', 660, 0.25, 0.28),
  ko:    ()=>beep('triangle', 120, 0.35, 0.32),
  ui:    ()=>beep('sine', 520, 0.06, 0.16)
};
let musicOsc=null;
function musicStart(){
  if(!GAME_CONFIG.audio.soundOn||musicOsc) return;
  const g = audioCtx.createGain(); g.gain.value=GAME_CONFIG.audio.master*0.06;
  const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=110;
  o.connect(g).connect(audioCtx.destination); o.start(); musicOsc=o;
}
function musicStop(){ if(musicOsc){ musicOsc.stop(); musicOsc=null; } }

/* ========================
   ENTITY + COMBAT
   ======================== */
class Fighter{
  constructor(name,x,flip=false,isCPU=false,base){
    Object.assign(this, {
      name,x, y:GAME_CONFIG.groundY, vy:0, flip, isCPU,
      w:base.width, h:base.height,
      health:base.maxHealth, stamina:base.maxStamina, super:0,
      lastDash: -9999, state:'idle', facing:flip?-1:1, hitting:false,
      move:{ kind:null, t:0, window:0 }, hitstunUntil:0, dodgeUntil:0,
      knockdowns:0, comboUntil:0, lastHitAt:0, acc:{swings:0,hits:0}
    });
  }
  rect(){ return {x:this.x-this.w/2, y:this.y-this.h, w:this.w, h:this.h}; }
  centerX(){ return this.x; }
  alive(){ return this.health>0; }
  canAct(t){ return t>this.hitstunUntil && t>this.dodgeUntil && !this.hitting; }
}
function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function moveHitbox(f, kind){
  const M = GAME_CONFIG.moves[kind];
  const reach = M.range;
  const hw = 20, hh = 22;
  const dir = f.flip?-1:1;
  const x = f.x + dir*(f.w/2 + reach - hw/2);
  const y = f.y - f.h*0.55;
  return {x:x, y:y, w:hw, h:hh, dmg:M.dmg, knock:M.knock, kind};
}

/* ========================
   AI (Finite State)
   ======================== */
class SimpleAI{
  constructor(fighter, diff){ this.f = fighter; this.diff = diff; this.state='idle'; this.nextThink=0; }
  think(t, player, dist){
    if(t<this.nextThink) return;
    const d = this.diff, f=this.f;
    this.nextThink = t + 120 + rand(-60,80);
    const lowStam = f.stamina<25;
    const playerAggro = player.move.kind?1:0;
    const wantDefend = chance(0.25*d.aiDefend) || lowStam || playerAggro;
    const wantAggro = chance(0.35*d.aiAggro) && !wantDefend;
    if(dist>150 && wantAggro){ this.state='approach'; return; }
    if(dist<70 && wantDefend){ this.state= chance(0.5)?'defend':'retreat'; return; }
    if(wantAggro && f.canAct(t) && f.stamina>12){
      const r=Math.random();
      const move = r<0.5?'jab':(r<0.8?'hook':'upper');
      this.state='attack_'+move; return;
    }
    this.state = lowStam? 'retreat':'idle';
  }
  update(t, player, dt){
    const f=this.f; const dist = Math.abs(player.x - f.x); const dir = Math.sign(player.x - f.x);
    this.think(t, player, dist);
    switch(this.state){
      case 'approach': f.x += dir * GAME_CONFIG.enemy.moveSpeed * this.diff.enemySpeed; break;
      case 'retreat':  f.x -= dir * (GAME_CONFIG.enemy.moveSpeed*0.9); break;
      case 'defend':
        if(chance(0.6*this.diff.aiDefend) && f.canAct(t)) startBlock(f,t);
        else if(chance(0.35*this.diff.aiDefend) && f.canAct(t)) startDodge(f,t);
        break;
      case 'attack_jab':
      case 'attack_hook':
      case 'attack_upper':
        if(dist<90 && f.canAct(t)){ const mv=this.state.split('_')[1]; startMove(f,mv,t,true); }
        else { this.state='approach'; }
        break;
      default: f.x += rand(-0.4,0.4);
    }
  }
}

/* ========================
   GAME STATE
   ======================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const state = {
  running:false, paused:false, debug:false,
  round:1, bestOf:GAME_CONFIG.round.bestOf,
  seconds:GAME_CONFIG.round.seconds, sudden:false,
  lastTick: performance.now(), acc:0, step:1000/60,
  comboTexts:[], particles:[],
  difficulty:'Normal',
  reduceFlashing:false, colorBlind:false,
  stats:{ player:{swings:0,hits:0,damage:0}, enemy:{swings:0,hits:0,damage:0} }
};

let player=null, enemy=null, ai=null;

/* ========================
   ROUND / MATCH FLOW
   ======================== */
function spawnFighters(){
  const d = GAME_CONFIG.DIFFICULTY[state.difficulty];
  player = new Fighter('Player', GAME_CONFIG.ring.left+140, false, false, GAME_CONFIG.player);
  enemy  = new Fighter('CPU',    GAME_CONFIG.ring.right-140, true,  true,  GAME_CONFIG.enemy);
  enemy.health = enemy.maxHealth = Math.round(GAME_CONFIG.enemy.maxHealth * d.enemyHp);
  enemy.stamina= enemy.maxStamina= GAME_CONFIG.enemy.maxStamina;
  ai = new SimpleAI(enemy, d);
}
function resetRound(seconds=GAME_CONFIG.round.seconds){
  state.seconds=seconds; state.sudden=false;
  document.getElementById('roundTag').textContent = `Round ${state.round} / ${GAME_CONFIG.round.bestOf}`;
  document.getElementById('timer').textContent = fmtTime(state.seconds);
  spawnFighters();
  SFX.bell();
}

/* ========================
   MOVES / ACTIONS
   ======================== */
function startMove(f, kind, t, isEnemy=false){
  const M = GAME_CONFIG.moves[kind];
  if(!M) return;
  if(f.stamina < M.stamina) return;
  f.hitting = true; f.move={kind, t, window:t + (f.isCPU?GAME_CONFIG.enemy.comboWindowMs:GAME_CONFIG.player.comboWindowMs)};
  f.acc.swings++;
  if(!isEnemy) state.stats.player.swings++; else state.stats.enemy.swings++;
  f.stamina = Math.max(0, f.stamina - M.stamina);
  SFX.punch();
}
function startBlock(f,t){ f.state='block'; f.blockUntil = t+240; SFX.block(); }
function startDodge(f,t){ f.state='dodge'; f.dodgeUntil = t + (f.isCPU? GAME_CONFIG.enemy.dodgeIFrames : GAME_CONFIG.player.dodgeIFrames); SFX.dodge(); }
function startSuper(f,t){
  const maxS = f.isCPU?GAME_CONFIG.enemy.maxSuper:GAME_CONFIG.player.maxSuper;
  if(f.super < maxS) return;
  f.super = 0; startMove(f,'super',t,f.isCPU); SFX.superR();
}

/* ========================
   DAMAGE / HIT RESOLUTION
   ======================== */
function applyHit(att, vic, hb, t){
  let dmg = hb.dmg;
  const cfg = vic.isCPU?GAME_CONFIG.enemy:GAME_CONFIG.player;
  if(vic.state==='block'){ dmg = Math.round(dmg * (1 - cfg.blockMitigation)); SFX.block(); }
  else { SFX.hit(); }
  if(t<vic.dodgeUntil) return; // i-frames

  vic.health = Math.max(0, vic.health - dmg);
  if(att.isCPU){ state.stats.enemy.damage+=dmg; state.stats.enemy.hits++; }
  else { state.stats.player.damage+=dmg; state.stats.player.hits++; }

  const attMaxS = att.isCPU?GAME_CONFIG.enemy.maxSuper:GAME_CONFIG.player.maxSuper;
  const vicMaxS = vic.isCPU?GAME_CONFIG.enemy.maxSuper:GAME_CONFIG.player.maxSuper;
  att.super = clamp(att.super + (att.isCPU?GAME_CONFIG.enemy.superGainOnHit:GAME_CONFIG.player.superGainOnHit), 0, attMaxS);
  vic.super = clamp(vic.super + (vic.isCPU?GAME_CONFIG.enemy.superGainOnBlock:GAME_CONFIG.player.superGainOnBlock), 0, vicMaxS);

  const push = (att.isCPU?GAME_CONFIG.enemy.pushback:GAME_CONFIG.player.pushback) * hb.knock * (att.flip?-1:1);
  vic.x += push*8;
  vic.hitstunUntil = t + (vic.isCPU?GAME_CONFIG.enemy.hitstunMs:GAME_CONFIG.player.hitstunMs);

  if(t<att.comboUntil){ spawnFloating(`${hb.kind==='super'?'SUPER!':'+combo'}`, att.x, att.y-110, '#ffd166'); }
  att.comboUntil = t + (att.isCPU?GAME_CONFIG.enemy.comboWindowMs:GAME_CONFIG.player.comboWindowMs);
  att.lastHitAt = t;

  if(vic.health<=0){ SFX.ko(); }
}
function spawnFloating(txt,x,y,color){ state.comboTexts.push({txt,x,y,vy:-0.3,a:1,color}); }
function spawnSpark(x,y){ state.particles.push({x,y,dx:rand(-1,1),dy:rand(-2,-0.4),life:300}); }

/* ========================
   UPDATE LOOP
   ======================== */
function update(dt){
  const t = nowMs();
  if(state.paused||!state.running) return;

  state._elapsed = (state._elapsed||0)+dt/1000;
  if(state._elapsed>=1){
    state._elapsed=0;
    state.seconds = Math.max(0, state.seconds-1);
    document.getElementById('timer').textContent = fmtTime(state.seconds);
    if(state.seconds===0){
      if(!state.sudden){
        state.sudden = true; state.seconds = GAME_CONFIG.round.suddenDeath;
        document.getElementById('timer').textContent = fmtTime(state.seconds);
        SFX.bell();
      } else { endRoundByHP(); return; }
    }
  }

  if(player && enemy){
    player.facing = (enemy.x>player.x)?1:-1;
    enemy.facing  = (player.x>enemy.x)?1:-1;

    const pMove = (isDown('left')?-1:0) + (isDown('right')?1:0);
    player.x += pMove * GAME_CONFIG.player.moveSpeed;

    if(isDown('stepF') && t>player.lastDash+GAME_CONFIG.player.dashCd){
      player.lastDash=t; player.x += player.facing * (GAME_CONFIG.player.dash*10);
      player.stamina = Math.max(0, player.stamina - GAME_CONFIG.player.staminaDrainMove);
    }
    if(isDown('stepB') && t>player.lastDash+GAME_CONFIG.player.dashCd){
      player.lastDash=t; player.x -= player.facing * (GAME_CONFIG.player.dash*10);
      player.stamina = Math.max(0, player.stamina - GAME_CONFIG.player.staminaDrainMove);
    }

    if(player.canAct(t)){
      if(isDown('block')) startBlock(player,t);
      else if(isDown('dodge')) startDodge(player,t);
      else if(isDown('jab')) startMove(player,'jab',t,false);
      else if(isDown('hook')) startMove(player,'hook',t,false);
      else if(isDown('upper')) startMove(player,'upper',t,false);
      else if(isDown('super')) startSuper(player,t);
    } else if(player.state==='block' && t>(player.blockUntil||0)) {
      player.state='idle';
    }

    ai.update(t, player, dt);

    const L=GAME_CONFIG.ring.left, R=GAME_CONFIG.ring.right;
    player.x = clamp(player.x, L, R);
    enemy.x  = clamp(enemy.x,  L, R);

    if(!player.hitting && player.state!=='block') player.stamina = clamp(player.stamina + GAME_CONFIG.player.staminaRegen*dt/1000, 0, GAME_CONFIG.player.maxStamina);
    if(!enemy.hitting  && enemy.state!=='block')  enemy.stamina  = clamp(enemy.stamina + GAME_CONFIG.enemy.staminaRegen*dt/1000, 0, GAME_CONFIG.enemy.maxStamina);

    stepMove(player, enemy, t);
    stepMove(enemy, player, t);

    if(player.health<=0 || enemy.health<=0){ endRoundByKO(); }
  }

  for(const fx of state.comboTexts){ fx.y+=fx.vy; fx.a-=0.01; }
  state.comboTexts = state.comboTexts.filter(fx=>fx.a>0);

  for(const p of state.particles){ p.x+=p.dx; p.y+=p.dy; p.dy+=0.03; p.life-=dt; }
  state.particles = state.particles.filter(p=>p.life>0);

  setBars();
}
function stepMove(att, vic, t){
  const m = att.move; if(!m.kind) return;
  const M = GAME_CONFIG.moves[m.kind];
  const elapsed = t - m.t;
  if(elapsed > M.startup && elapsed < M.startup + M.active && !m._hit){
    const hb = moveHitbox(att, m.kind);
    if(vic && aabb(hb, vic.rect())){
      applyHit(att, vic, hb, t);
      spawnSpark(hb.x+hb.w/2, hb.y+hb.h/2);
      m._hit = true;
    }
  }
  if(elapsed > (M.startup+M.active+M.recovery)){
    att.hitting=false; att.move={kind:null,t:0,window:0};
  }
}

/* ========================
   RENDER
   ======================== */
function render(){
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  // Background (crowd parallax)
  ctx.save();
  ctx.fillStyle = '#0b0c10';
  ctx.fillRect(0,0,w,h);
  for(let i=0;i<GAME_CONFIG.crowd.layers;i++){
    const y = 120 + i*28;
    ctx.fillStyle = `rgba(${40+i*20},${45+i*20},${70+i*25},${0.35 - i*0.07})`;
    for(let x=0;x<w;x+=24){
      const j = Math.sin((x+i*130 + performance.now()*0.0007*(i+1))) * GAME_CONFIG.crowd.amplitude;
      ctx.fillRect(x, y+j, 16, 16);
    }
  }
  // Ring
  ctx.fillStyle='#1c2030';
  ctx.fillRect(60, GAME_CONFIG.groundY-10, w-120, 20);
  ctx.strokeStyle='#9bb8ff'; ctx.lineWidth=3;
  for(let r=0;r<3;r++){
    const ry = GAME_CONFIG.ring.ropeY + r*20;
    ctx.beginPath(); ctx.moveTo(80,ry); ctx.lineTo(w-80,ry); ctx.stroke();
  }

  // Fighters — only if spawned
  if (player && enemy) {
    drawFighter(player);
    drawFighter(enemy);
  } else {
    ctx.fillStyle='#9bb8ff';
    ctx.font='700 20px Arial';
    ctx.fillText('Press ▶ Play to start', w/2 - 120, GAME_CONFIG.groundY - 140);
  }

  // Particles
  for(const p of state.particles){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect(p.x, p.y, 3,3); }

  // Floating texts
  for(const fx of state.comboTexts){
    ctx.globalAlpha = Math.max(0,fx.a);
    ctx.fillStyle = fx.color||'#fff';
    ctx.font='700 16px Arial';
    ctx.fillText(fx.txt, fx.x, fx.y);
    ctx.globalAlpha = 1;
  }

  // Debug
  if(state.debug && player && enemy){
    ctx.strokeStyle='#00ff88';
    drawRect(player.rect());
    drawRect(enemy.rect());
    ctx.fillStyle='#fff';
    ctx.fillText(`AI:${ai?.state||'—'}`, enemy.x-30, enemy.y - enemy.h - 14);
    ctx.fillText(`FPS: ~60`, 10, 20);
  }
  ctx.restore();
}
function drawFighter(f){
  const {x,y,w,h,flip} = f;
  const baseX = Math.floor(x - w/2), baseY = Math.floor(y - h);
  const skin = '#fbd6a3';
  const torso = f.isCPU ? '#6ea8fe' : '#7bf1a8';
  const glove = f.isCPU ? '#ff8a8a' : '#ffd166';
  const pant  = '#2a2e42';

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(x, y-4, 26, 8, 0, 0, Math.PI*2); ctx.fill();

  // Legs
  ctx.fillStyle=pant;
  ctx.fillRect(baseX, baseY+h-36, w/2-4, 36);
  ctx.fillRect(baseX+w/2+4, baseY+h-36, w/2-4, 36);

  // Torso
  ctx.fillStyle=torso; ctx.fillRect(baseX, baseY+22, w, 48);

  // Head
  ctx.fillStyle=skin; ctx.fillRect(baseX+8, baseY, w-16, 22);

  // Arms
  ctx.fillStyle=skin;
  const armY = baseY+28;
  if(!flip){ ctx.fillRect(baseX-12, armY, 14, 18); ctx.fillRect(baseX+w-2, armY, 14, 18); }
  else     { ctx.fillRect(baseX+w-2, armY, 14, 18); ctx.fillRect(baseX-12, armY, 14, 18); }

  // Gloves
  ctx.fillStyle=glove;
  if(!flip){ ctx.fillRect(baseX-18, armY+12, 16, 12); ctx.fillRect(baseX+w+6, armY+12, 16, 12); }
  else     { ctx.fillRect(baseX+w+6, armY+12, 16, 12); ctx.fillRect(baseX-18, armY+12, 16, 12); }

  // Face (eyes)
  ctx.fillStyle='#111';
  ctx.fillRect(baseX+14, baseY+8, 4, 4);
  ctx.fillRect(baseX+w-22, baseY+8, 4, 4);

  // Wind-up cue
  if(f.hitting){ ctx.strokeStyle='#ffffff33'; ctx.beginPath(); ctx.arc(x + (f.flip?-10:10), baseY+40, 14, 0, Math.PI*2); ctx.stroke(); }
}
function drawRect(r){ ctx.strokeRect(r.x, r.y, r.w, r.h); }

/* Bars + HUD binding (null-guard) */
function setBars(){
  const pH = document.getElementById('pHealth'), pS=document.getElementById('pStamina'), pSu=document.getElementById('pSuper');
  const eH = document.getElementById('eHealth'), eS=document.getElementById('eStamina'), eSu=document.getElementById('eSuper');

  if (player){
    pH.style.width = `${(player.health/player.maxHealth)*100}%`;
    pS.style.width = `${(player.stamina/player.maxStamina)*100}%`;
    pSu.style.width= `${(player.super/(GAME_CONFIG.player.maxSuper))*100}%`;
  } else { pH.style.width = pS.style.width = pSu.style.width = '0%'; }

  if (enemy){
    eH.style.width = `${(enemy.health/ enemy.maxHealth)*100}%`;
    eS.style.width = `${(enemy.stamina/enemy.maxStamina)*100}%`;
    eSu.style.width= `${(enemy.super/(GAME_CONFIG.enemy.maxSuper))*100}%`;
  } else { eH.style.width = eS.style.width = eSu.style.width = '0%'; }

  if(GAME_CONFIG.UI.colorBlind){
    [pH,eH].forEach(el=>el.style.background='linear-gradient(90deg,#ffb3c1,#ff6b6b)');
    [pS,eS].forEach(el=>el.style.background='linear-gradient(90deg,#c1ffd7,#63e6be)');
    [pSu,eSu].forEach(el=>el.style.background='linear-gradient(90deg,#bcd0ff,#6ea8fe)');
  }
}

/* ========================
   ROUND END / RESULTS
   ======================== */
function endRoundByKO(){
  state.paused=true; state.running=false;
  const winner = (player && player.health>0) ? 'You Win!' : 'CPU Wins!';
  showModal('KO!', modalResultsHTML(winner), ()=>SFX.ko());
}
function endRoundByHP(){
  state.paused=true; state.running=false;
  const pHp = player?player.health:0, eHp = enemy?enemy.health:0;
  const winner = pHp>=eHp ? 'You Win (by decision)!' : 'CPU Wins (by decision)!';
  showModal('Time!', modalResultsHTML(winner), ()=>SFX.bell());
}
function modalResultsHTML(winner){
  const accP = state.stats.player.swings? Math.round(100*state.stats.player.hits/state.stats.player.swings):0;
  const accE = state.stats.enemy.swings? Math.round(100*state.stats.enemy.hits/state.stats.enemy.swings):0;
  return `
    <div class="grid">
      <div class="stat" style="font-size:1.2rem">${winner}</div>
      <div class="grid grid2">
        <div>
          <div><strong>Player</strong></div>
          <div>Damage: ${state.stats.player.damage}</div>
          <div>Accuracy: ${accP}%</div>
          <div>Combos Landed: (demo) ${Math.floor(state.stats.player.hits/4)}</div>
        </div>
        <div>
          <div><strong>CPU</strong></div>
          <div>Damage: ${state.stats.enemy.damage}</div>
          <div>Accuracy: ${accE}%</div>
          <div>Combos Landed: (demo) ${Math.floor(state.stats.enemy.hits/4)}</div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="btnPlayAgain">Play Again</button>
      </div>
    </div>`;
}

/* ========================
   MAIN LOOP
   ======================== */
function loop(ts){
  try{
    const dt = ts - state.lastTick; state.lastTick = ts;
    state.acc += dt;
    while(state.acc >= state.step){ update(state.step); state.acc -= state.step; }
    render();
  }catch(err){
    console.error('[Block Brawl] runtime error:', err);
    state.running=false;
  }
  requestAnimationFrame(loop);
}

/* ========================
   UI / MODALS / SETTINGS
   ======================== */
const modal = {
  root: document.getElementById('modalBackdrop'),
  title: document.getElementById('modalTitle'),
  body: document.getElementById('modalBody'),
  close: document.getElementById('modalClose')
};
function showModal(title, html, onOpen){
  modal.title.textContent=title;
  modal.body.innerHTML = html;
  modal.root.style.display='flex';
  if(onOpen) onOpen();
}
function closeModal(){ modal.root.style.display='none'; SFX.ui(); }
document.getElementById('modalClose').addEventListener('click', closeModal);
modal.root.addEventListener('click', (e)=>{ if(e.target===modal.root) closeModal(); });

/* Tutorial on first visit */
(function tutorial(){
  const seen = localStorage.getItem('bb_seen');
  if(!seen){
    localStorage.setItem('bb_seen','1');
    showModal('How to Play', `
      <div class="grid">
        <div>Move <span class="k">A/D</span> or <span class="k">←/→</span>, Dash <span class="k">W/S</span> or <span class="k">↑/↓</span></div>
        <div>Punches: <span class="k">J</span> Jab, <span class="k">K</span> Hook, <span class="k">L</span> Uppercut</div>
        <div>Defense: <span class="k">I</span> Block, <span class="k">O</span> Dodge</div>
        <div>Super: <span class="k">Space</span> (when full)</div>
        <div>Pause: <span class="k">P</span>, Debug: <span class="k">/</span>, Restart: <span class="k">R</span></div>
        <div class="small">Win 1 round by KO or by having more HP when time ends.</div>
      </div>
    `);
  }
})();

/* Controls (simple remap) */
document.getElementById('btnControls').addEventListener('click',()=>{
  const names = Object.keys(KEY_MAP);
  let html = `<div class="grid">`;
  for(const n of names){
    const val = KEY_MAP[n].join(', ');
    html += `<div class="row"><div class="grow"><strong>${n}</strong></div><input data-k="${n}" class="select" placeholder="${val}" value="${val}"/></div>`;
  }
  html += `<div class="row" style="justify-content:flex-end"><button id="saveKeys" class="btn">Save</button></div></div>`;
  showModal('Controls', html);
  document.getElementById('saveKeys').addEventListener('click', ()=>{
    const inputs = modal.body.querySelectorAll('input[data-k]');
    inputs.forEach(inp=>{
      const name = inp.getAttribute('data-k');
      const arr = inp.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
      KEY_MAP[name]=arr;
    });
    localStorage.setItem('bb_keys', JSON.stringify(KEY_MAP));
    closeModal();
  });
});

/* Accessibility */
document.getElementById('btnAccessibility').addEventListener('click',()=>{
  const chk = (id,label,checked)=> `<label class="row"><input type="checkbox" id="${id}" ${checked?'checked':''}/>&nbsp;${label}</label>`;
  showModal('Accessibility', `
    <div class="grid">
      ${chk('accSound','Sound On', GAME_CONFIG.audio.soundOn)}
      ${chk('accReduce','Reduce flashing / screenshake', GAME_CONFIG.audio.reduceFlashing)}
      ${chk('accCB','Color-blind friendly HUD', GAME_CONFIG.UI.colorBlind)}
      <div class="small">Settings save automatically.</div>
    </div>
  `);
  ['accSound','accReduce','accCB'].forEach(id=>{
    modal.body.querySelector('#'+id).addEventListener('change',(e)=>{
      if(id==='accSound'){ GAME_CONFIG.audio.soundOn = e.target.checked; if(!e.target.checked) musicStop(); }
      if(id==='accReduce'){ GAME_CONFIG.audio.reduceFlashing = e.target.checked; }
      if(id==='accCB'){ GAME_CONFIG.UI.colorBlind = e.target.checked; }
      localStorage.setItem('bb_cfg', JSON.stringify({audio:GAME_CONFIG.audio, UI:GAME_CONFIG.UI}));
    });
  });
});

/* Difficulty selector */
document.getElementById('selDiff').addEventListener('change',(e)=>{
  state.difficulty = e.target.value;
  SFX.ui();
});

/* Play / Pause */
function startGame(){
  // Resume AudioContext on user gesture (Chrome/Firefox mobile policy)
  if(audioCtx.state === 'suspended'){ audioCtx.resume(); }
  state.stats = { player:{swings:0,hits:0,damage:0}, enemy:{swings:0,hits:0,damage:0} };
  state.round=1; resetRound();
  state.running=true; state.paused=false; musicStart();
}
document.getElementById('btnPlay').addEventListener('click', startGame);
document.getElementById('btnPause').addEventListener('click', ()=>{ state.paused=!state.paused; SFX.ui(); });

/* Global hotkeys */
addEventListener('keydown', (e)=>{
  if(e.key==='p'||e.key==='P'){ state.paused=!state.paused; }
  if(e.key==='/'){ state.debug=!state.debug; }
  if(e.key==='r'||e.key==='R'){ startGame(); }
});

/* Restore saved config */
(function restore(){
  const saved = JSON.parse(localStorage.getItem('bb_cfg')||'null');
  if(saved){ Object.assign(GAME_CONFIG.audio, saved.audio||{}); Object.assign(GAME_CONFIG.UI, saved.UI||{}); }
  document.getElementById('selDiff').value = state.difficulty;
})();

/* ========================
   BOOT
   ======================== */
requestAnimationFrame(loop);

/* ========================
   ACCEPTANCE CHECKLIST
   ========================
   [x] Single-file, offline, no external assets
   [x] Keyboard-only play; tutorial on first launch
   [x] Easy/Normal/Hard with AI behavior scaling
   [x] Health/Stamina/Super bars; super attack
   [x] Jab/Hook/Uppercut, block & dodge (i-frames)
   [x] Hit-stun, pushback, simple combos & floating text
   [x] Pause/Debug/Restart; no console errors
   [x] 60 FPS target; fixed timestep loop
   [x] All tuning in GAME_CONFIG
*/
</script>
</body>
</html>
